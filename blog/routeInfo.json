{"template":"../src/pages/blog.js","sharedHashesByProp":{},"data":{"posts":[{"title":"Player bleeding in Source SDK","slug":"bleeding-in-source","date":"2019-11-5","mins":12,"summary":"A random feature I added to a HL2MP mod was for the player to bleed for a bit after being shot, it uses HL2 particles to bleed from bullet holes for a specified amount of time.","contents":"<p>A random feature I added to a HL2MP mod was for the player to bleed for a bit after being shot, it uses HL2 particles to bleed from bullet holes for a specified amount of time. Here&#39;s how I did it:</p>\n<p>First we set up some variables in hl2mp_player.h</p>\n<pre><code class=\"language-cpp\">CNetworkVar( bool, m_bBleeding );\nVector bleedPos;\nVector bleedDir;\nfloat m_flBleedingTime;\nint bleedingAmount;</code></pre>\n<p>and then set the defaults for bleeding in hl2mp_player.cpp (Spawn function)</p>\n<pre><code class=\"language-cpp\">m_bBleeding = false;\nm_flBleedingTime = 0.0f;\nbleedingAmount = 0;</code></pre>\n<p>Still in hl2mp_player but in PostThink we do the actual bleeding based on these variables:</p>\n<pre><code class=\"language-cpp\">if( m_bBleeding &amp;&amp; bleedingAmount &gt; 0 &amp;&amp; m_flBleedingTime &lt; gpGlobals-&gt;curtime )\n{\n    //Bleed a little bit\n    TakeHealth( -1, DMG_GENERIC );\n\n    //Decrement\n    bleedingAmount--;\n    m_flBleedingTime = gpGlobals-&gt;curtime + BLEED_TIME;\n\n    //Finished bleeding\n    if( !bleedingAmount )\n        m_bBleeding = false;\n\n    //Spawn blood\n    UTIL_BloodSpray( bleedPos * GetAbsOrigin(), bleedDir, BloodColor(), bleedingAmount, FX_BLOODSPRAY_ALL );\n    UTIL_BloodDrips( bleedPos, bleedDir, BloodColor(), bleedingAmount );\n}</code></pre>\n<p>Now to actually start bleeding when damage is taken, so in OnTakeDamage we do this:</p>\n<pre><code class=\"language-cpp\">if( inputInfo.GetMaxDamage() != -1.0f )\n{\n    //Bleed!\n    m_bBleeding = true;\n    m_flBleedingTime = gpGlobals-&gt;curtime;\n    bleedingAmount = (int)ceil((float)inputInfo.GetDamage() / 5.0f);\n\n    Vector vecDir = vec3_origin;\n    if( inputInfo.GetInflictor() )\n    {\n        vecDir = inputInfo.GetInflictor()-&gt;WorldSpaceCenter() - Vector ( 0, 0, 10 ) - WorldSpaceCenter();\n        VectorNormalize( vecDir );\n    }\n\n    //Store last took damage\n    bleedPos = inputInfo.GetDamagePosition() / GetAbsOrigin();\n    bleedDir = vecDir;\n}</code></pre>\n<p>Here if the player is damaged we store the direction of the shot and calculate the position based on the offset on the players position. Now we need to network it so the player can see the blood on their end so we pop this in the send table as always:</p>\n<pre><code class=\"language-cpp\">SendPropBool( SENDINFO( m_bBleeding ) )</code></pre>\n<p>and add this to the recieve table in c_hl2mp_player.cpp:</p>\n<pre><code class=\"language-cpp\">RecvPropBool( RECVINFO( m_bBleeding ) )</code></pre>\n<p>and add two new variables to c_hl2mp_player.h:</p>\n<pre><code class=\"language-cpp\">//Bleeding\nbool m_bBleeding;\nfloat m_flTrailTime;</code></pre>\n<p>and set the defaults in Spawn (back in the cpp file) to this:</p>\n<pre><code class=\"language-cpp\">//Bleeding\nm_bBleeding = false;\nm_flTrailTime = 0.0f;</code></pre>\n<p>and now in ClientThink we do the bleeding for the local player!</p>\n<pre><code class=\"language-cpp\">//Bleed!\nif( m_bBleeding &amp;&amp; m_flTrailTime &lt; gpGlobals-&gt;curtime &amp;&amp; GetGroundEntity() )\n{\n    //Do a traceline from the player downwards\n    trace_t tr;\n    UTIL_TraceLine( GetAbsOrigin(), GetAbsOrigin()*Vector(0,0,-10), MASK_SOLID, this, COLLISION_GROUP_NONE, &amp;tr );\n\n    //Draw blood decal and increase time\n    UTIL_BloodDecalTrace( &amp;tr, BLOOD_COLOR_RED );\n    m_flTrailTime = gpGlobals-&gt;curtime+0.5f;\n}</code></pre>\n"},{"title":"Showing Legs in Source SDK","slug":"legs-in-source","date":"2019-08-05T00:00:00.000Z","mins":4,"summary":"An interesting addition to Aftermath was to show the legs of the player, each player could look down at their own player model which allowed each player to have a kind of representation in the game as they can see themselves and know which character they are","contents":"<p>An interesting addition to Aftermath was to show the legs of the player, each player could look down at their own player model which allowed each player to have a kind of representation in the game as they can see themselves and know which character they are.</p>\n<p>This post will be for singleplayer as this is the latest example I have but multiplayer should be similar since it&#39;s only client side code. All the code is in c_baseplayer.cpp &amp; h, first you make sure the model is set for the player:</p>\n<pre><code class=\"language-cpp\">void C_BasePlayer::Spawn( void )\n{\n    SetModel( &quot;models/myplayermodel/playermodel.mdl&quot; );\n}</code></pre>\n<p>This is because the legs come from the player model and the default has no animations and will not look great, next we&#39;ll move the model back so the camera doesn&#39;t clip with the camera.</p>\n<pre><code class=\"language-cpp\">const Vector&amp; C_BasePlayer::GetRenderOrigin( void )\n{\n    //Dont apply in thirdperson\n    if( IsLocalPlayer() &amp;&amp; !input-&gt;CAM_IsThirdPerson() )\n    {\n        static Vector forward;\n        AngleVectors( GetRenderAngles(), &amp;forward );\n\n        // Shift the render origin by a fixed amount\n        forward *= -25;\n        forward += GetAbsOrigin();\n\n        return forward;\n    }else{\n        return BaseClass::GetRenderOrigin();\n    }\n}</code></pre>\n<p>Here we determine the forward position (if we&#39;re not in thirdperson) and use it to change the render origin of the model back a bit, you can change 25 to whatever you want or even use a convar and test it in game.</p>\n<pre><code class=\"language-cpp\">ConVar cl_legs( &quot;cl_legs&quot;, &quot;1&quot;, 0, &quot;Enable or disable player leg rendering&quot;, true, 0, true, 1 );\n\nint C_BasePlayer::DrawModel( int flags )\n{\n    //Ignore if the convar is enabled\n    if( !cl_legs.GetBool() )\n        return 0;\n\n    CMatRenderContextPtr context(materials);\n\n    //Don&#39;t render above a certain height of the body\n    if ( IsLocalPlayer() &amp;&amp; !input-&gt;CAM_IsThirdPerson() )\n    {\n        if ( (GetFlags() &amp; FL_DUCKING) || m_Local.m_bDucking )\n        {\n            context-&gt;SetHeightClipMode(MATERIAL_HEIGHTCLIPMODE_RENDER_BELOW_HEIGHT);\n            context-&gt;SetHeightClipZ(GetAbsOrigin().z+27);\n        }else{\n            context-&gt;SetHeightClipMode(MATERIAL_HEIGHTCLIPMODE_RENDER_BELOW_HEIGHT);\n            context-&gt;SetHeightClipZ(GetAbsOrigin().z+50);\n        }\n    }\n\n    //Draw the model\n    int nDrawRes = BaseClass::DrawModel(flags);\n\n    // Remove height clipping\n    context-&gt;SetHeightClipMode(MATERIAL_HEIGHTCLIPMODE_DISABLE);\n\n    return nDrawRes;\n}</code></pre>\n<p>Here we clip the player model to remove the upperbody and even lower if the player is ducking, there&#39;s also a convar for disabling the legs.</p>\n<p>That&#39;s pretty much it, if you have access to the player models another option is to create a bodygroup and disable several parts of the body as you see fit but this is the easiest option.</p>\n"},{"title":"HTML UI in Source SDK","slug":"html-ui-in-source","date":"2018-12-23T00:00:00.000Z","mins":7,"summary":"I always think I've reached the limits of the Source engine but I think I'm just not giving the engine enough credit, for Resurgence we keep messing around with the UI and one day I had an idea for using the HTML control for it which will allow it to be prototyped faster and allow non-programmers to provide a proper representation instead of an image.","contents":"<p>I always think I&#39;ve reached the limits of the Source engine but I think I&#39;m just not giving the engine enough credit, for Resurgence we keep messing around with the UI and one day I had an idea for using the HTML control for it which will allow it to be prototyped faster and allow non-programmers to provide a proper representation instead of an image.</p>\n<p>I had heard of awesomium but that&#39;s a bit messy and seems to be dead so I started with the HTML VGUI control which creates a CEF off-screen renderer for rendering and renders the result onto a VGUI panel, this was great as a starting point until I noticed a major issue when overriding the main menu VGUI element.</p>\n<h3 id=\"transparency\">Transparency</h3>\n<p>Resurgence has a cool main menu background map and for some reason Valve decided they didn&#39;t need transparency when rendering the HTML control, I poked around a bit and came to the conclusion that pretty much everything was in the chromehtml DLL and although the source is available I wasn&#39;t able to get it built with a old version of CEF.</p>\n<p>I didn&#39;t give up and instead had an idea to use a chroma key and set the background to green, this kinda worked but created issues for text and any transparency that we decided to use for the menu. I kept looking for a solution and while checking out the <a href=\"%22https://github.com/ValveSoftware/source-sdk-2013%22\">Source SDK Github</a> I noticed that the HTML control was slightly different to my version which was weird because Valve have pretty much abandoned it.. I compared the two and basically the off-screen renderer is now handled by the Steam client using the API so I copied over the required files for the HTML control and new Steam API code (which also requires new steam_api and steamvr DLLs) and the off-screen renderer was using a transparent background!</p>\n<h3 id=\"navigation\">Navigation</h3>\n<p>Now that the rendering was working and a HTML file was being loaded I began coding the menu flow and trying to figure out how the user will navigate around the menu. I didn&#39;t want a natural website with static HTML files because I wasn&#39;t sure how opening a bunch of HTML files would look or how fluid it would be so I poked around Javascript libraries and decided to use Vue and it&#39;s Router for navigation.</p>\n<p>The Vue router uses hashes to pretend to be a URL, hashes are normally used for anchors to scroll a user to a specific point but with Javascript you can dynamically set, read and react to hash changes so you can navigate to #/play and Vue will swap an entire section from the default component to another component setup when initialising Vue router with a transition.</p>\n<h3 id=\"data\">Data</h3>\n<p>Now that I had some kind of structure for the new menu I needed to get game data over to Vue and bind it for buttons, text and images. Communication from C++ to the off-screen renderer is very limited compared to if you setup CEF yourself but there&#39;s one function called &quot;ExecuteJavascript&quot; which does exactly what it says and allows you to send JS code.</p>\n<p>The best way would be to use a JSON library to create a structure and send it over once the HTML file has loaded to init Vue, the only issue is Source is pretty old and doesn&#39;t have a JSON library so after trying 3-4 different libs I ended up using <a href=\"%22http://rapidjson.org/%22\">RapidJSON</a> since most newer libs use features that the 2010 built tools don&#39;t support.</p>\n<p>The structure contained the different paths and content within the paths, each button either had a URL to another route or had a custom protocol (res://) that did something specific like loading a map or opening a Steam overlay URL which the mod would handle:</p>\n<pre><code class=\"language-cpp\">const char* url = data-&gt;GetString(&quot;url&quot;);\n\nCUtlVector&lt;char*, CUtlMemory&lt;char*, int&gt;&gt; strs;\nV_SplitString(url, &quot;/&quot;, strs);\nstrs.Remove(0);//remove &quot;res:&quot;\n\nif (strs.Count() &gt;= 0)\n{\n    if (strcmp(strs[0], &quot;menu&quot;) == 0)\n    {\n        char str[100];\n        Q_strncpy(str, &quot;gamemenucommand &quot;, sizeof(str));\n        Q_strncat(str, strs[1], sizeof(str), COPY_ALL_CHARACTERS);\n\n        engine-&gt;ClientCmd(str);\n    }\n    else if (strcmp(strs[0], &quot;command&quot;) == 0)\n    {\n        engine-&gt;ClientCmd(strs[1]);\n    }\n    else if (strcmp(strs[0], &quot;play&quot;) == 0)\n    {\n        g_pCVar-&gt;RevertFlaggedConVars(FCVAR_REPLICATED);\n        g_pCVar-&gt;RevertFlaggedConVars(FCVAR_CHEAT);\n\n        char szMapCommand[1024];\n        Q_snprintf(szMapCommand, sizeof(szMapCommand), &quot;disconnect\\nwait\\nwait\\nsv_lan 0\\nsetmaster enable\\nmaxplayers 1\\nhostname \\&quot;Game Name\\&quot;\\nprogress_enable\\nmap %s\\n&quot;, strs[1]);\n\n        // exec\n        engine-&gt;ClientCmd_Unrestricted(szMapCommand);\n    }\n    else if (strcmp(strs[0], &quot;achievements&quot;) == 0)\n        steamapicontext-&gt;SteamFriends()-&gt;ActivateGameOverlay(&quot;Achievements&quot;);\n}</code></pre>\n<h3 id=\"in-game-state\">In-game state</h3>\n<p>The menu is also used in game and since the UI is now custom the menu it looks exactly the same and needs to be reset when entering a level so I had to check for the engine-&gt;IsInGame() flag to see if it has changed and reset the HTML control and tell Vue to render some components differently, I ended up using the new map game event and navigating the page to root using the router like so:</p>\n<pre><code class=\"language-cpp\">void FireGameEvent(IGameEvent *event)\n{\n    if (strcmp(event-&gt;GetName(), &quot;game_newmap&quot;) != 0)\n        return;\n\n        ...\n\n    html-&gt;RunJavascript(&quot;navigateTo(&#39;/&#39;)&quot;);\n\n        ...\n}</code></pre>\n<p>As well as navigating back to home, the internal JS game data object is updated with an inGame flag so features such as changing the main menu can be achieved.</p>\n<h3 id=\"final-points\">Final points</h3>\n<p>I&#39;ve been slowly expanding the menu out to have difficulty selection, collectibles, loadout and want to move achievements to it. I also recently swapped to using webpack to compile all the vue components into 1-2 js files which is easier to deal with. Here&#39;s a video showing a bit of it:</p>\n<iframe style=\"display: block; margin-left: auto; margin-right: auto;max-width:560px\" src=\"https://www.youtube.com/embed/eyWjmHOO4ko\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"315\" frameborder=\"0\"></iframe>"},{"title":"Enabling brush ladders","slug":"enabling-brush-ladders","date":"2018-7-10","mins":7,"summary":"A request while working on Resurgence was to add brush ladders which are a simpler implementation that don't use dismount points but instead fling you off the ladder at the top or bottom.","contents":"<p>A request while working on Resurgence was to add brush ladders which are a simpler implementation that don&#39;t use dismount points but instead fling you off the ladder at the top or bottom, they are way easier to create in Hammer and easier to use as a player.</p>\n<p>I found out how to do it when searching about the brush ladder and found this <a href=\"%22https://developer.valvesoftware.com/wiki/Co-Operative_Base_(Mod)%22\">page</a> that listed it had managed to enable brush ladders, I checked out the source code for the enabling the brush ladder and it basically just disables the HL2 gamemovement that uses the gamemovement.cpp file as it&#39;s base and has some extra ladder code for handling dismounts. You can check out the file <a href=\"%22https://github.com/whoozzem/SecobMod/blob/master/mp/src/game/shared/hl2/hl_gamemovement.cpp%22\">here</a></p>\n<p>After that any brushes with func_ladder or textures with the climbable flag can be used as ladders, I would recommend changing the climb speed in shareddefs.h (103) and altering the velocity that the player gets pushed away from the ladder at which by default is <a href=\"%22https://github.com/ValveSoftware/source-sdk-2013/blob/master/sp/src/game/shared/gamemovement.cpp#L2939%22\">270</a>.</p>\n<p>It was way easier than I expected as whenever I went to tackle the issue I would look in func_ladder or gamemovement.cpp and didn&#39;t think about checking out the HL2 specific movement rules..</p>\n<p>Code is available on my Github as always, just replace your file with the file in <a href=\"%22https://gist.github.com/tingtom/5a3a92e7146eea8b74873a78edcb8dca%22\">this gist</a></p>\n"},{"title":"What is Aftermath? (2/2)","slug":"what-is-aftermath-2","date":"2018-3-11","mins":18,"summary":"What is Aftermath? Aftermath is a Source SDK mod created and started by me for learning the Source engine and for fun. The mod was inspired from the infamous \"zombies\" mode in Black Ops after having a lot of fun playing it with friends, the original idea was to fully replicate the mode as much as possible with sounds and models from the game.","contents":"<p>With the mod being inspired from Call of Duty Zombies I had to change a lot of things that HL2 does, in the end the mod became more of a full conversion than the original concept of using the HL2 pistol against HL2 walking zombies.</p>\n<p>The first thing I tested was how the zombies react and get to the player since the existing AI meant the zombies would get bored and walk away from the player, I also tested barricades a lot using brushes with a wood texture using the template entity but it wasn&#39;t working until I got better at coding and made my own baricade entity.</p>\n<h3 id=\"spawning-zombies\">Spawning Zombies</h3>\n<p>The monster_maker entity was the main source of figuring out how to create an endless amount of zombies, the monster_maker takes a template npc and a reference point for spawning the npcs and for some time was the way all the zombies in the mod were spawned (with some changes).</p>\n<p>Some custom code was added to the monster_maker so that the health and damage of the zombie being spawned could be changed, health was already exposed in the SetHealth function so I could easily change the health based on the current round and other factors such as insta kill (which sets the health to 1).</p>\n<p>The old template way of spawning zombies was later changed to use:</p>\n<pre><code class=\"language-cpp\">CreateEntityByName( &quot;npc_zombie&quot; )</code></pre>\n<p>and was changed so only one entity had to be made (zs_zombiemaker) and up to 100 zs_spawnpoint entities could be made anywhere on the map and be toggled on and off individually which helped map makers make maps easier!</p>\n<h3 id=\"changing-ai\">Changing AI</h3>\n<p>The zombies still had some difficulty finding the player after being spawned so some changes had to be made to how the zombies found the player and in the future how they navigate the map. The changes to these functions in the ai_senses file overrides how zombies find the player so that they can always been found:</p>\n<pre><code class=\"language-cpp\">bool CAI_Senses::Look( CBaseEntity *pSightEnt )\n{\n    CNPC_BaseZombie *pZombie = dynamic_cast&lt;CNPC_BaseZombie*&gt;( GetOuter() );\n    if ( pZombie &amp;&amp; pSightEnt-&gt;IsPlayer() &amp;&amp; pSightEnt-&gt;m_lifeState == LIFE_ALIVE )\n    {\n        return SeeEntity( pSightEnt );\n    }\n    else\n    {\n        if ( WaitingUntilSeen( pSightEnt ) )\n            return false;\n\n        if ( ShouldSeeEntity( pSightEnt ) &amp;&amp; CanSeeEntity( pSightEnt ) )\n        {\n            return SeeEntity( pSightEnt );\n        }\n        return false;\n    }\n}</code></pre>\n<p>In the above code, if the current NPC is a zombie and the entity being seen is a player and is alive the player is seen no matter what. This allows the zombie to find the player anywhere in the map.</p>\n<pre><code class=\"language-cpp\">int CAI_Senses::LookForHighPriorityEntities( int iDistance )\n{\n    int nSeen = 0;\n    if ( gpGlobals-&gt;curtime - m_TimeLastLookHighPriority &gt; AI_HIGH_PRIORITY_SEARCH_TIME )\n    {\n        AI_PROFILE_SENSES(CAI_Senses_LookForHighPriorityEntities);\n        m_TimeLastLookHighPriority = gpGlobals-&gt;curtime;\n\n        BeginGather();\n\n        float distSq = ( iDistance * iDistance );\n        const Vector &amp;origin = GetAbsOrigin();\n\n        CNPC_BaseZombie *pZombie = dynamic_cast&lt;CNPC_BaseZombie*&gt;( GetOuter() );\n\n        for ( int i = 1; i &lt;= gpGlobals-&gt;maxClients; i++ )\n        {\n            CBaseEntity *pPlayer = UTIL_PlayerByIndex( i );\n\n            if ( pPlayer )\n            {\n                if ( (origin.DistToSqr(pPlayer-&gt;GetAbsOrigin()) &lt; distSq || pZombie) &amp;&amp; Look( pPlayer ) )\n                {\n                    nSeen++;\n                }\n            }\n        }\n\n        EndGather( nSeen, &amp;m_SeenHighPriority );\n    }\n    else\n    {\n        for ( int i = m_SeenHighPriority.Count() - 1; i &gt;= 0; --i )\n        {\n            if ( m_SeenHighPriority[i].Get() == NULL )\n                m_SeenHighPriority.FastRemove( i );                \n        }\n        nSeen = m_SeenHighPriority.Count();\n    }\n\n    return nSeen;\n}</code></pre>\n<p>The above code overrides the distance check between the NPC and the player if the NPC is a zombie.</p>\n<h3 id=\"weapons\">Weapons</h3>\n<p>The final item for this blog post is the weapons, the weapon system needs to be stripped apart and put back together again. The HL2 weapon system didn&#39;t make sense for the mod so I had to get rid of slots and change how weapons where picked up and brought from walls. First I disabled the HUD elements for weapon selection which involved removing code in the <strong>weapon_selection.cpp</strong> and <strong>weapons_resource.cpp</strong> files and then began changing how weapons are picked up.</p>\n<p>The original way a weapon is picked up in HL2 is using BumpWeapon which is called by the weapon itself when a player touches it at line 840 in the file basecombatweapon_shared.cpp, I override some things in the BumpWeapon function so only specific weapons can be picked up (most notably the starting pistol which is placed at the players feet in the level).</p>\n<p>There&#39;s a second way that weapons can be picked up and that&#39;s the Use handler in the basecombatweapon.cpp file which is a fix so when weapons are &quot;used&quot; they can be equipped but I used this to equip the weapon instead:</p>\n<pre><code class=\"language-cpp\">void CBaseCombatWeapon::Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value )\n{\n    CHL2MP_Player *pPlayer = ToHL2MPPlayer( pActivator );\n\n    if ( pPlayer )\n    {\n        m_OnPlayerUse.FireOutput( pActivator, pCaller );\n\n        if ( pPlayer-&gt;UseWeapon( this ) )\n        {\n            OnPickedUp( pPlayer );\n        }\n    }\n}</code></pre>\n<p>The UseWeapon function handles points, messages and sounds for buying weapons:</p>\n<pre><code class=\"language-cpp\">bool CHL2MP_Player::UseWeapon( CBaseCombatWeapon *pWeapon )\n{\n    // Don&#39;t let the player fetch weapons through walls (use MASK_SOLID so that you can&#39;t pickup through windows)\n    if( !pWeapon-&gt;FVisible( this, MASK_SOLID ) &amp;&amp; !(GetFlags() &amp; FL_NOTARGET) )\n    {\n        return false;\n    }\n\n    bool bOwnsWeaponAlready = !!Weapon_OwnsThisType( pWeapon-&gt;GetClassname(), pWeapon-&gt;GetSubType());\n\n    if ( bOwnsWeaponAlready == true ) \n    {\n        //has enough points to get ammo\n        if( points &gt;= pWeapon-&gt;GetAmmoPointCost() )\n        {\n             if ( Weapon_EquipAmmoOnly( pWeapon ) )\n             {\n                 RemovePoints( pWeapon-&gt;GetAmmoPointCost() );\n                 EmitSound( &quot;Door.Buy&quot; );\n\n                 pWeapon-&gt;Respawn();\n                 UTIL_Remove( pWeapon );\n                 return true;\n             }\n             else\n             {\n                 return false;\n             }\n        }else{\n            //error message\n            hudtextparms_s tTextParam;\n            tTextParam.x            = -1;\n            tTextParam.y            = 0.60;\n            tTextParam.effect        = 0;\n\n            tTextParam.r1            = FlashlightIsOn() ? 153 : 255;//153\n            tTextParam.g1            = FlashlightIsOn() ? 153 : 255;\n            tTextParam.b1            = FlashlightIsOn() ? 153 : 255;\n            tTextParam.a1            = 255;\n\n            tTextParam.r2            = FlashlightIsOn() ? 153 : 255;\n            tTextParam.g2            = FlashlightIsOn() ? 153 : 255;\n            tTextParam.b2            = FlashlightIsOn() ? 153 : 255;\n            tTextParam.a2            = 255;\n\n            tTextParam.fadeinTime    = 0;\n            tTextParam.fadeoutTime    = 0;\n\n            tTextParam.holdTime        = 4;\n            tTextParam.fxTime        = 0;\n            tTextParam.channel        = 1;\n\n            UTIL_HudMessage( this, tTextParam, &quot;Not enough points&quot; );\n\n            return false;\n        }\n    }\n\n    if ( points &gt;= pWeapon-&gt;GetPointCost() )\n    {\n        RemovePoints( pWeapon-&gt;GetPointCost() );\n        EmitSound( &quot;Door.Buy&quot; );\n\n        pWeapon-&gt;Respawn();\n        Weapon_Equip( pWeapon );\n\n        return true;\n    }else{\n        //error message\n\n        hudtextparms_s tTextParam;\n        tTextParam.x            = -1;\n        tTextParam.y            = 0.60;\n        tTextParam.effect        = 0;\n\n        tTextParam.r1            = FlashlightIsOn() ? 153 : 255;//153\n        tTextParam.g1            = FlashlightIsOn() ? 153 : 255;\n        tTextParam.b1            = FlashlightIsOn() ? 153 : 255;\n        tTextParam.a1            = 255;\n\n        tTextParam.r2            = FlashlightIsOn() ? 153 : 255;\n        tTextParam.g2            = FlashlightIsOn() ? 153 : 255;\n        tTextParam.b2            = FlashlightIsOn() ? 153 : 255;\n        tTextParam.a2            = 255;\n\n        tTextParam.fadeinTime    = 0;\n        tTextParam.fadeoutTime    = 0;\n\n        tTextParam.holdTime        = 4;\n        tTextParam.fxTime        = 0;\n        tTextParam.channel        = 1;\n\n        UTIL_HudMessage( this, tTextParam, &quot;Not enough points&quot; );\n\n        return false;\n    }\n\n    return false;\n}</code></pre>\n<p>I suggest handling messages better, probably in a new nicely animated HUD element. There&#39;s some more features but I&#39;ll save these for a third blog post, one of the things I wanted to talk about was the navmesh implementation that was used to replace the node system as I kept running into limitations in hammer.</p>\n"},{"title":"ambient_generic OnEnd event","slug":"ambient-generic-onend-event","date":"2018-1-16","mins":20,"summary":"A quick snippet of code for the ambient_generic entity that will fire an output event when the sound has finished.","contents":"<p>A quick snippet of code for the ambient_generic entity that will fire an output event when the sound has finished, useful for playing sounds one after another or whatever else you can come up with!</p>\n<p>First you need two variables, one for tracking the end of the sound and another for the output event itself. Oh and a definition for a new think context for tracking the end, these all need to go in the CAmbientGeneric constructor in the public section:</p>\n<pre><code class=\"language-cpp\">void EndThink();\n\nfloat endTime;\nCOutputEvent m_OnEnd;</code></pre>\n<p>These then need going in the BEGIN_DATADESC section:</p>\n<pre><code class=\"language-cpp\">DEFINE_OUTPUT(m_OnEnd, &quot;OnEnd&quot;),\nDEFINE_FIELD( endTime, FIELD_FLOAT),\nDEFINE_FUNCTION( EndThink ),</code></pre>\n<p>The endTime variable needs a default value so it can be setup to track the end of the sound, I usually set this to a value like -1. This goes in the Spawn function of the CAmbientGeneric class aswell as some code to setup the think function for tracking the end of the sound.</p>\n<pre><code class=\"language-cpp\">endTime = -1.0f;\n\nRegisterThinkContext(&quot;EndContext&quot;);\nSetContextThink(&amp;CAmbientGeneric::EndThink, gpGlobals-&gt;curtime, &quot;EndContext&quot;);\nSetNextThink(TICK_NEVER_THINK, &quot;EndContext&quot;);</code></pre>\n<p>This code sets up a new think context so it can be controlled independently from the other think function called RampThink, this think doesn&#39;t start straight away and is only started in the Activate and ToggleSound functions of the CAmbientGeneric class:</p>\n<pre><code class=\"language-cpp\">SetNextThink(gpGlobals-&gt;curtime + 0.1f, &quot;EndContext&quot;);</code></pre>\n<p>The end of the ToggleSound function should look like this:</p>\n<pre><code class=\"language-cpp\">InitModulationParms();\n\nSendSound( SND_NOFLAGS ); // send sound\n\nSetNextThink( gpGlobals-&gt;curtime + 0.1f );\nSetNextThink(gpGlobals-&gt;curtime + 0.1f, &quot;EndContext&quot;);</code></pre>\n<p>The only missing part now is the EndThink function:</p>\n<pre><code class=\"language-cpp\">void CAmbientGeneric::EndThink()\n{\n    //Get duration of the file\n    if (endTime == -1.0f)\n        endTime = gpGlobals-&gt;curtime + enginesound-&gt;GetSoundDuration((char *)STRING(m_iszSound));\n    else\n        //Became inactive\n        if (!m_fActive || gpGlobals-&gt;curtime &gt; endTime)\n        {\n            m_OnEnd.FireOutput(this, this);\n            endTime = -1.0f;\n            return;\n        }\n\n\n    SetNextThink(gpGlobals-&gt;curtime + 1.0f, &quot;EndContext&quot;);\n}</code></pre>\n<p>This first checks the endTime variable to see if it&#39;s set or not and sets it to the duration of the current sound if it&#39;s not, if it is set a check is made to see if the sound was stopped on purpose or if the duration of the sound has elapsed. The endTime variable is then reset and the think function returns which means SetNextThink isn&#39;t called again so the EndThink code won&#39;t run until the sound is played again.</p>\n"},{"title":"Physgun Weapon","slug":"physgun-weapon","date":"2017-8-16","mins":5,"summary":"Back when I worked on Zombie Survival I got bored one day and seeked out how to implement and use the Physgun that everyone saw in the HL2 beta trailer, this code was leaked back when HL2 was coming out and never ended up in the final game.","contents":"<p>Back when I worked on Zombie Survival I got bored one day and seeked out how to implement and use the Physgun that everyone saw in the HL2 beta trailer, this code was leaked back when HL2 was coming out and never ended up in the final game.</p>\n<p>Recently someone asked about it so I decided to make this post and release the code I gathered on it, this version works very well and has a new feature which allows you to freeze and unfreeze objects. While testing the code I also found out a way to get the original beam code working so this also includes that, back when I first worked on it the beam was replaced with a serverside straight beam to the object.</p>\n<p>The source code is available <a href=\"%22https://gist.github.com/tingtom/47ef360d3183b41676e2552c8193bb1f%22\">here</a>, there&#39;s no need to edit the c_weapon__stubs_hl2 file like other weapons since the weapon declares itself you just need add the physgun.cpp file to the server project and the c_weapon_gravitygun.cpp file to the client project.</p>\n<p>Video of the weapon:</p>\n<iframe style=\"display: block; margin-left: auto; margin-right: auto;max-width:560px\" src=\"//www.youtube.com/embed/OEVRGoE1T7o?rel=0\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"315\" frameborder=\"0\"></iframe>"},{"title":"World Hints","slug":"world-hints","date":"2017-7-26","mins":17,"summary":"World hints are snippets of information in the level that help the user navigate or progress through the game. The one's I added to Resurgence used a specific font and had three sizes, they where placed in the level using a hammer entity and always faced the player.","contents":"<p>World hints are snippets of information in the level that help the user navigate or progress through the game. The one&#39;s I added to Resurgence used a specific font and had three sizes, they where placed in the level using a hammer entity and always faced the player which is called billboarding.</p>\n<p>So to implement this in your very own mod you first need to add the worldhint.cpp file for the server-side entity that&#39;s setup by hammer so that the level designer can create a worldhint entity with a font size, hint scale and the text for the hint itself.</p>\n<pre><code class=\"language-cpp\">#include &quot;cbase.h&quot;\n\nclass CWorldHint : public CBaseEntity\n{\npublic:\n    DECLARE_CLASS( CWorldHint, CBaseEntity );\n    DECLARE_SERVERCLASS();\n\n    CWorldHint();\n    void Spawn();\n    void Activate();\n\n    //Always send to all clients\n    int UpdateTransmitState()\n    {\n        return SetTransmitState( FL_EDICT_ALWAYS );\n    }\n\nprivate:\n    CNetworkString( hint, MAX_PATH );\n    CNetworkVar( int, fontSize );\n    CNetworkVar( float, scalar );\n\n    string_t m_String_tHint;\n\nprotected:\n    DECLARE_DATADESC();\n};\n\nLINK_ENTITY_TO_CLASS( worldhint, CWorldHint )\n\nBEGIN_DATADESC( CWorldHint )\n    DEFINE_KEYFIELD( m_String_tHint, FIELD_STRING, &quot;Hint&quot; ),\n    DEFINE_KEYFIELD( fontSize, FIELD_INTEGER, &quot;Size&quot; ),\n    DEFINE_KEYFIELD( scalar, FIELD_FLOAT, &quot;Scalar&quot; )\nEND_DATADESC()\n\nIMPLEMENT_SERVERCLASS_ST( CWorldHint, DT_WorldHint )\n    SendPropString( SENDINFO( hint ) ),\n    SendPropInt( SENDINFO( fontSize ) ),\n    SendPropFloat( SENDINFO( scalar ) ),\nEND_SEND_TABLE()\n\nCWorldHint::CWorldHint()\n{\n    fontSize = 1;\n    memset( hint.GetForModify(), 0, sizeof( hint ) );\n}\n\nvoid CWorldHint::Spawn()\n{\n    SetModelName( MAKE_STRING( &quot;worldhint&quot; ) );\n    SetSolid( SOLID_NONE );\n    SetMoveType( MOVETYPE_NONE );\n\n    Precache();\n    SetModel( STRING( GetModelName() ) );\n\n    AddEffects( EF_NOSHADOW | EF_NORECEIVESHADOW );\n}\n\nvoid CWorldHint::Activate()\n{\n    BaseClass::Activate();\n    Q_strncpy( hint.GetForModify(), STRING( m_String_tHint ), 255 );\n}</code></pre>\n<p>This is a pretty basic entity setup, the only special thing it does is copy the hint text from hammer to the variable used to send the info over to the client. It also completely hides itself as it&#39;s clientside only. This following server-side code is only 200 lines long and does the rest, first it creates a VGUI panel then sets up correct angles and world position and then proceeds to render the VGUI element in the world using the magic function called <a href=\"%22https://developer.valvesoftware.com/wiki/IMatSystemSurface%22\">DrawPanelIn3DSpace</a>.</p>\n<pre><code class=\"language-cpp\">#include &quot;cbase.h&quot;\n#include &quot;fmtstr.h&quot;\n\n//Vgui render stuff\n#include &quot;VGuiMatSurface/IMatSystemSurface.h&quot;\n#include &lt;vgui_controls/Panel.h&gt;\n#include &lt;vgui_controls/Label.h&gt;\n#include &lt;vgui/ISurface.h&gt;\n\n//Debugging\n#include &quot;debugoverlay_shared.h&quot;\n\n//\n//    Special hint panel used for drawing\n//\nclass HintPanel : public vgui::Panel\n{\npublic:\n    HintPanel( const char *text, int fontSize ) : fontSize( fontSize )\n    {\n        SetVisible( true );\n        SetPos( 0, 0 );\n\n        //Create basic label\n        label = new vgui::Label( this, &quot;&quot;, text );\n        label-&gt;SetPos( 0, 0 );\n    }\n\n    void ApplySchemeSettings( vgui::IScheme *pScheme )\n    {\n        //Get the font and set the label\n        vgui::HFont textFont = pScheme-&gt;GetFont( CFmtStr( &quot;WorldHint%i&quot;, fontSize ) );\n        label-&gt;SetFont( textFont );\n\n        //Get the labels text in wchar format\n        wchar_t wText[256];\n        label-&gt;GetText( wText, 256 );\n\n        //Calculate the texts size\n        int w, h;\n        vgui::surface()-&gt;GetTextSize( textFont, wText, w, h );\n\n        //Set the label and panels size to the texts size\n        label-&gt;SetSize( w, h );\n        SetSize( w, h );\n    }\n\nprivate:\n    vgui::Label *label;\n    int fontSize;\n};\n\nConVar res_debug_worldhint( &quot;res_debug_worldhint&quot;, &quot;0&quot; );\nConVar res_worldhint( &quot;res_worldhint&quot;, &quot;1&quot; );\n\n//\n//    Client-side worldhint entity for rendering the actual hint\n//\nclass C_WorldHint : public C_BaseEntity\n{\npublic:\n    DECLARE_CLASS( C_WorldHint, C_BaseEntity );\n    DECLARE_CLIENTCLASS();\n\n    C_WorldHint()\n    {\n        hintPanel = NULL;\n    }\n\n    virtual int DrawModel( int flags );\n    virtual void OnDataChanged( DataUpdateType_t type );\n\n    virtual void GetRenderBounds( Vector &amp;vecMins, Vector &amp;vecMaxs )\n    {\n        //Calculate the bounds for the hint\n        Vector half = Vector( width/2.0f, width/2.0f, height/2.0f );\n        vecMins.Init( -half.x, -half.y, -half.z );\n        vecMaxs.Init( half.x, half.y, half.z );\n\n        //Debug the bounds\n        if( res_debug_worldhint.GetBool() )\n            NDebugOverlay::Box( GetAbsOrigin(), vecMins, vecMaxs, 255, 0, 0, 128, 1.0f );\n    }\n\n    //Matrix stuff\n    void ComputePanelToWorld();\n    Vector CalculateOrigin( QAngle angles );\n    QAngle CalculateAngle();\n\nprivate:\n    char hint[MAX_PATH];\n    int fontSize;\n    float scalar;\n    VMatrix m_PanelToWorld;\n\n    //Panel stuff\n    float width, height;\n    int pWidth, pHeight;\n    HintPanel *hintPanel;\n};\n\nLINK_ENTITY_TO_CLASS( worldhint, C_WorldHint );\n\nIMPLEMENT_CLIENTCLASS_DT( C_WorldHint, DT_WorldHint, CWorldHint )\n    RecvPropString( RECVINFO( hint ) ),\n    RecvPropInt( RECVINFO( fontSize ) ),\n    RecvPropFloat( RECVINFO( scalar ) ),\nEND_RECV_TABLE()\n\nvoid C_WorldHint::OnDataChanged( DataUpdateType_t type )\n{\n    //We have some data to use\n    if( type == DATA_UPDATE_CREATED )\n    {\n        //Create the hint panel with our data\n        hintPanel = new HintPanel( hint, fontSize );\n        hintPanel-&gt;InvalidateLayout( true, true );//Setup scheme stuff\n        hintPanel-&gt;GetSize( pWidth, pHeight );\n\n        //\n        width = (float)pWidth/scalar;\n        height = (float)pHeight/scalar;\n    }\n\n    BaseClass::OnDataChanged( type );\n}\n\nVector C_WorldHint::CalculateOrigin( QAngle angles )\n{\n    Vector vecOrigin = GetAbsOrigin();\n\n    //Get the angle vectors\n    Vector xaxis, yaxis;\n    AngleVectors( angles, &amp;xaxis, &amp;yaxis, NULL );\n\n    //Transform the x and y axis to center it\n    VectorMA( vecOrigin, -(width/2), xaxis, vecOrigin );\n    VectorMA( vecOrigin, -(height/2), yaxis, vecOrigin );\n\n    //Return new origin\n    return vecOrigin;\n}\n\nQAngle C_WorldHint::CalculateAngle()\n{\n    //Get the player\n    C_BasePlayer *pLocalPlayer = C_BasePlayer::GetLocalPlayer();\n    if( !pLocalPlayer )\n        return vec3_angle;\n\n    //Get the direction between this and the player\n    Vector target = GetAbsOrigin()-(pLocalPlayer-&gt;GetAbsOrigin()+Vector(0,0,pLocalPlayer-&gt;GetPlayerMaxs().z/2));\n\n    //Convert to angles\n    QAngle angles;\n    VectorAngles( target, angles );\n\n    //Fix angles\n    angles[YAW] += 90;\n    angles[ROLL] = (-angles[PITCH])-90;\n    angles[PITCH] = 180;\n\n    //Return angles\n    return angles;\n}\n\nvoid C_WorldHint::ComputePanelToWorld()\n{\n    //Get out angle and origin\n    QAngle angles = CalculateAngle();\n    Vector origin = CalculateOrigin( angles );\n\n    //Set the matrix to them\n    m_PanelToWorld.SetupMatrixOrgAngles( origin, angles );\n\n    //Debug\n    if( res_debug_worldhint.GetBool() )\n    {\n        NDebugOverlay::Box( GetAbsOrigin(), Vector( -2,-2,-2 ), Vector( 2, 2, 2 ), 0, 255, 0, 255, 0.01f );\n        NDebugOverlay::Box( origin, Vector( -2,-2,-2 ), Vector( 2, 2, 2 ), 255, 0, 0, 255, 0.01f );\n    }\n}\n\nint C_WorldHint::DrawModel( int flags )\n{\n    //Client doesn&#39;t want to render these\n    if( !res_worldhint.GetBool() )\n        return 0;\n\n    //Wait for a panel to draw\n    if( !hintPanel )\n        return 0;\n\n    //Calculate the origin and angles\n    ComputePanelToWorld();\n\n    //Draw the panel\n    g_pMatSystemSurface-&gt;DrawPanelIn3DSpace( hintPanel-&gt;GetVPanel(), m_PanelToWorld, \n        pWidth, pHeight, width, height );\n\n    return 1;\n}</code></pre>\n<p>The source code is also available in this <a href=\"%22https://gist.github.com/tingtom/4b2240b1d681d1e59bdcd338b0823b91%22\">Gist</a>.</p>\n"},{"title":"Looping Sprint Sounds","slug":"looping-sprint-sounds","date":"2017-5-6","mins":5,"summary":"I have added two sprint loops to HL2 mods and both were done in slightly different ways, a sprint loop is a sound that plays over and over again while the player is sprinting and adds a \"realistic\" sound to go with the sprint key instead of something like the HL2 whoosh sound when you press the key.","contents":"<p>I have added two sprint loops to HL2 mods and both were done in slightly different ways, a sprint loop is a sound that plays over and over again while the player is sprinting and adds a &quot;realistic&quot; sound to go with the sprint key instead of something like the HL2 whoosh sound when you press the key.</p>\n<p>The first sprint loop has one sprint sound that loops normally while sprinting but is faded out and in which is all done in code, first we check if the player is sprinting by checking the boolean flag and making sure the player is actually moving by checking the velocity:</p>\n<pre><code class=\"language-cpp\">bool running = (m_fIsSprinting &amp;&amp; GetAbsVelocity().Length2D() &gt; 40);</code></pre>\n<p>I coded the entire sprint block differently before but figured I can make it work and look better, the beginning of the block is an if statement to check if the player is running or if the start sprint time is larger than zero since the default is zero then the EmitSound structure is created and filled with the sound name and a flag:</p>\n<pre><code class=\"language-cpp\">if( running || m_fSprintStart &gt; 0.0f)\n{\n    EmitSound_t t;\n    t.m_pSoundName = &quot;Player.SprintLoop&quot;;\n    t.m_nFlags = SND_CHANGE_VOL;</code></pre>\n<p>After this I do a check to see if the start sprint time is larger than zero again and if the player is not running which means the fade in was started and the player has just stopped running. This is when we do the fade out and final stopping of the loop/reset of the code:</p>\n<pre><code class=\"language-cpp\">if( m_fSprintStart &gt; 0.0f &amp;&amp; !running )\n{\n    float diff = gpGlobals-&gt;curtime - m_fSprintEnd;\n\n    //Fadeout under 1 seconds\n    if( diff &lt; 1.0f )\n        t.m_flVolume = 1 - diff / 1.0f;\n    else {\n        m_fSprintStart = 0.0f;\n        m_fSprintEnd = 0.0f;\n        t.m_nFlags = SND_STOP;\n    }\n} else {</code></pre>\n<p>In the above code we calculate the different of the current time and the time when the sprinting finished, the fade out lasts for 1 second so I only fade out if the difference is below 1 second and then use that to reduce the volume of the sound which is enabled by the flag set earlier. if the difference is larger than 1 second both variables are reset and the flag is set to SND_STOP which will stop the emitting of the sound.</p>\n<p>Next we do something similar to the fade out where we check the difference from the start sound and use that to fade in the volume:</p>\n<pre><code class=\"language-cpp\">    float diff = gpGlobals-&gt;curtime - m_fSprintStart;\n\n    //Fadein under 3 seconds\n    if( diff &lt; 3.0f )\n        t.m_flVolume = diff / 3.0f;\n}</code></pre>\n<p>After this we do a normal EmitSound and pass the &quot;t&quot; structure created earlier:</p>\n<pre><code class=\"language-cpp\">CPASAttenuationFilter filter( this );\nfilter.UsePredictionRules();\nEmitSound(filter, entindex(), t );</code></pre>\n<p>All of the sprint code has been put in the PostThink of the hl2_player.cpp file and I have two variables in the header file for the start time of the sprint and the end time of the sprint, click here for the full source code in a gist and here&#39;s the result in video form:</p>\n<iframe style=\"display: block; margin-left: auto; margin-right: auto;max-width:560px\" src=\"https://www.youtube.com/embed/0RxOiKM2xqA?rel=0\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"315\" frameborder=\"0\"></iframe>"},{"title":"What is Resurgence","slug":"what-is-resurgence","date":"2017-5-1","mins":5,"summary":"Resurgence is a full conversion HL2 mod by Jacol which was started before I joined but required some customisation such as custom UI, a weapon skin system and other additions so since Jacol helped with Aftermath I accepted his offer to join and began working on Resurgence.","contents":"<p><a href=\"/projects/resurgence\">Resurgence</a> is a full conversion HL2 mod by Jacol which was started before I joined but required some customisation such as custom UI, a weapon skin system and other additions so since Jacol helped with Aftermath I accepted his offer to join and began working on Regurgence.</p>\n<p>A lot of features where added to the mod after time and it was being built farily fast with many custom models, materials and great maps being built by Jacol but the initial set of maps where lost and the mod was pushed back a lot, by this time the mod had been greenlit and Jacol wanted something to go out so a new mod was created called &quot;The Union&quot; which was a much smaller mod with less features.</p>\n<p>&quot;The Union&quot; or &quot;The Onion&quot; as I like to call it was easier to handle for me personally and had some interesting ideas and design, recently the mod was integrated back into Resurgence as a DLC addition because of recent Greenlight changes. Some features will be described on the Blog but nothing about the mod specificly that can spoil anything.</p>\n<p><img src=\"/images/posts/resurgence.webp\" alt=\"Resurgence screenshot\"></p>\n"},{"title":"What is Aftermath? (1/2)","slug":"what-is-aftermath-1","date":"2017-4-16","mins":15,"summary":"What is Aftermath? Aftermath is a Source SDK mod created and started by me for learning the Source engine and for fun. The mod was inspired from the infamous \"zombies\" mode in Black Ops after having a lot of fun playing it with friends, the original idea was to fully replicate the mode as much as possible with sounds and models from the game.","contents":"<p>What is Aftermath? Aftermath is a Source SDK mod created and started by me for learning the Source engine and for fun. The mod was inspired from the infamous &quot;zombies&quot; mode in Black Ops after having a lot of fun playing it with friends, the original idea was to fully replicate the mode as much as possible with sounds and models from the game but I was getting increasingly paranoid of being sued so this changed half way through development.</p>\n<p>The mod started off with Zombie Survival which was a terrible name to begin with and was purely used for testing but ended up sticking. Zombie Survival was going to be single player only because I had no idea how to do multiplayer so the first iteration was the singleplayer &quot;alpha&quot; version with a couple of maps which is what this blog post will be focussing on.</p>\n<p>We&#39;ll start with the maps:</p>\n<h3 id=\"zs_example-map\">zs_example map</h3>\n<p>zs_example was one of the only maps made by me, it&#39;s a square room with some stairs going up to a balcony that goes around the entire room it had some random rocks as unlockable doors and some weapons/grenades that you could buy. It looks terrible and those point lights could&#39;ve gone a little lower but it was going in the mod no matter what!</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"/images/posts/zs_example.jpg\" alt=\"zs_example map\"></td>\n<td><img src=\"/images/posts/zs_example_1.jpg\" alt=\"zs_example map 2\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"zs_factory-map\">zs_factory map</h3>\n<p>zs_factory was made by Sam or GR3AVE5Y and was actually built from zs_example but obviously looked a lot better, it had another floor which had a hole that broke when you stood on it that took you to the first floor kinda completed the loop that you would expect. There was a small room as you can see in the image below to the right that contained another zombie spawn and frag grenades.</p>\n<p>I believe this map was the only map made by Sam but a second one was being made but was never finished. The map was left in the map for some time as it aged well and in the future it did recieve some new additions such as the automatic turret and some new weapons.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"/images/posts/zs_factory.jpg\" alt=\"zs_factory map\"></td>\n<td><img src=\"/images/posts/zs_factory_1.jpg\" alt=\"zs_factory map 2\"></td>\n</tr>\n</tbody></table>\n<h3 id=\"zs_haywire-map\">zs_haywire map</h3>\n<p>zs_haywire was made by Poho and was a large area with stairs going up to a room, it was a pretty small map and didn&#39;t really work but I kept it in the mod as I always wanted to expand it. The map had some good ideas and looked good with the endless tunnel and fire effects so it stayed for some time until Poho made his second map.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><img src=\"/images/posts/zs_haywire.jpg\" alt=\"zs_haywire map\"></td>\n<td><img src=\"/images/posts/zs_haywire_1.jpg\" alt=\"zs_haywire map 2\"></td>\n</tr>\n</tbody></table>\n<p>Next time we&#39;ll go through the features that where implemented into <a href=\"/projects/aftermath\">Aftermath</a> and explain how a lot of them where done and why, some of the features where done from tutorials for example the ironsights but most are custom and I thought it would be best to explain them rather than hand out the entire source for the mod.</p>\n"}]},"path":"blog"}
