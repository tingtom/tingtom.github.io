{"template":"../src/containers/Post","sharedHashesByProp":{},"data":{"title":"What is Aftermath? (2/2)","slug":"what-is-aftermath-2","date":"2018-3-11","mins":18,"summary":"What is Aftermath? Aftermath is a Source SDK mod created and started by me for learning the Source engine and for fun. The mod was inspired from the infamous \"zombies\" mode in Black Ops after having a lot of fun playing it with friends, the original idea was to fully replicate the mode as much as possible with sounds and models from the game.","contents":"<p>With the mod being inspired from Call of Duty Zombies I had to change a lot of things that HL2 does, in the end the mod became more of a full conversion than the original concept of using the HL2 pistol against HL2 walking zombies.</p>\n<p>The first thing I tested was how the zombies react and get to the player since the existing AI meant the zombies would get bored and walk away from the player, I also tested barricades a lot using brushes with a wood texture using the template entity but it wasn&#39;t working until I got better at coding and made my own baricade entity.</p>\n<h3 id=\"spawning-zombies\">Spawning Zombies</h3>\n<p>The monster_maker entity was the main source of figuring out how to create an endless amount of zombies, the monster_maker takes a template npc and a reference point for spawning the npcs and for some time was the way all the zombies in the mod were spawned (with some changes).</p>\n<p>Some custom code was added to the monster_maker so that the health and damage of the zombie being spawned could be changed, health was already exposed in the SetHealth function so I could easily change the health based on the current round and other factors such as insta kill (which sets the health to 1).</p>\n<p>The old template way of spawning zombies was later changed to use:</p>\n<pre><code class=\"language-cpp\">CreateEntityByName( &quot;npc_zombie&quot; )</code></pre>\n<p>and was changed so only one entity had to be made (zs_zombiemaker) and up to 100 zs_spawnpoint entities could be made anywhere on the map and be toggled on and off individually which helped map makers make maps easier!</p>\n<h3 id=\"changing-ai\">Changing AI</h3>\n<p>The zombies still had some difficulty finding the player after being spawned so some changes had to be made to how the zombies found the player and in the future how they navigate the map. The changes to these functions in the ai_senses file overrides how zombies find the player so that they can always been found:</p>\n<pre><code class=\"language-cpp\">bool CAI_Senses::Look( CBaseEntity *pSightEnt )\n{\n    CNPC_BaseZombie *pZombie = dynamic_cast&lt;CNPC_BaseZombie*&gt;( GetOuter() );\n    if ( pZombie &amp;&amp; pSightEnt-&gt;IsPlayer() &amp;&amp; pSightEnt-&gt;m_lifeState == LIFE_ALIVE )\n    {\n        return SeeEntity( pSightEnt );\n    }\n    else\n    {\n        if ( WaitingUntilSeen( pSightEnt ) )\n            return false;\n\n        if ( ShouldSeeEntity( pSightEnt ) &amp;&amp; CanSeeEntity( pSightEnt ) )\n        {\n            return SeeEntity( pSightEnt );\n        }\n        return false;\n    }\n}</code></pre>\n<p>In the above code, if the current NPC is a zombie and the entity being seen is a player and is alive the player is seen no matter what. This allows the zombie to find the player anywhere in the map.</p>\n<pre><code class=\"language-cpp\">int CAI_Senses::LookForHighPriorityEntities( int iDistance )\n{\n    int nSeen = 0;\n    if ( gpGlobals-&gt;curtime - m_TimeLastLookHighPriority &gt; AI_HIGH_PRIORITY_SEARCH_TIME )\n    {\n        AI_PROFILE_SENSES(CAI_Senses_LookForHighPriorityEntities);\n        m_TimeLastLookHighPriority = gpGlobals-&gt;curtime;\n\n        BeginGather();\n\n        float distSq = ( iDistance * iDistance );\n        const Vector &amp;origin = GetAbsOrigin();\n\n        CNPC_BaseZombie *pZombie = dynamic_cast&lt;CNPC_BaseZombie*&gt;( GetOuter() );\n\n        for ( int i = 1; i &lt;= gpGlobals-&gt;maxClients; i++ )\n        {\n            CBaseEntity *pPlayer = UTIL_PlayerByIndex( i );\n\n            if ( pPlayer )\n            {\n                if ( (origin.DistToSqr(pPlayer-&gt;GetAbsOrigin()) &lt; distSq || pZombie) &amp;&amp; Look( pPlayer ) )\n                {\n                    nSeen++;\n                }\n            }\n        }\n\n        EndGather( nSeen, &amp;m_SeenHighPriority );\n    }\n    else\n    {\n        for ( int i = m_SeenHighPriority.Count() - 1; i &gt;= 0; --i )\n        {\n            if ( m_SeenHighPriority[i].Get() == NULL )\n                m_SeenHighPriority.FastRemove( i );                \n        }\n        nSeen = m_SeenHighPriority.Count();\n    }\n\n    return nSeen;\n}</code></pre>\n<p>The above code overrides the distance check between the NPC and the player if the NPC is a zombie.</p>\n<h3 id=\"weapons\">Weapons</h3>\n<p>The final item for this blog post is the weapons, the weapon system needs to be stripped apart and put back together again. The HL2 weapon system didn&#39;t make sense for the mod so I had to get rid of slots and change how weapons where picked up and brought from walls. First I disabled the HUD elements for weapon selection which involved removing code in the <strong>weapon_selection.cpp</strong> and <strong>weapons_resource.cpp</strong> files and then began changing how weapons are picked up.</p>\n<p>The original way a weapon is picked up in HL2 is using BumpWeapon which is called by the weapon itself when a player touches it at line 840 in the file basecombatweapon_shared.cpp, I override some things in the BumpWeapon function so only specific weapons can be picked up (most notably the starting pistol which is placed at the players feet in the level).</p>\n<p>There&#39;s a second way that weapons can be picked up and that&#39;s the Use handler in the basecombatweapon.cpp file which is a fix so when weapons are &quot;used&quot; they can be equipped but I used this to equip the weapon instead:</p>\n<pre><code class=\"language-cpp\">void CBaseCombatWeapon::Use( CBaseEntity *pActivator, CBaseEntity *pCaller, USE_TYPE useType, float value )\n{\n    CHL2MP_Player *pPlayer = ToHL2MPPlayer( pActivator );\n\n    if ( pPlayer )\n    {\n        m_OnPlayerUse.FireOutput( pActivator, pCaller );\n\n        if ( pPlayer-&gt;UseWeapon( this ) )\n        {\n            OnPickedUp( pPlayer );\n        }\n    }\n}</code></pre>\n<p>The UseWeapon function handles points, messages and sounds for buying weapons:</p>\n<pre><code class=\"language-cpp\">bool CHL2MP_Player::UseWeapon( CBaseCombatWeapon *pWeapon )\n{\n    // Don&#39;t let the player fetch weapons through walls (use MASK_SOLID so that you can&#39;t pickup through windows)\n    if( !pWeapon-&gt;FVisible( this, MASK_SOLID ) &amp;&amp; !(GetFlags() &amp; FL_NOTARGET) )\n    {\n        return false;\n    }\n\n    bool bOwnsWeaponAlready = !!Weapon_OwnsThisType( pWeapon-&gt;GetClassname(), pWeapon-&gt;GetSubType());\n\n    if ( bOwnsWeaponAlready == true ) \n    {\n        //has enough points to get ammo\n        if( points &gt;= pWeapon-&gt;GetAmmoPointCost() )\n        {\n             if ( Weapon_EquipAmmoOnly( pWeapon ) )\n             {\n                 RemovePoints( pWeapon-&gt;GetAmmoPointCost() );\n                 EmitSound( &quot;Door.Buy&quot; );\n\n                 pWeapon-&gt;Respawn();\n                 UTIL_Remove( pWeapon );\n                 return true;\n             }\n             else\n             {\n                 return false;\n             }\n        }else{\n            //error message\n            hudtextparms_s tTextParam;\n            tTextParam.x            = -1;\n            tTextParam.y            = 0.60;\n            tTextParam.effect        = 0;\n\n            tTextParam.r1            = FlashlightIsOn() ? 153 : 255;//153\n            tTextParam.g1            = FlashlightIsOn() ? 153 : 255;\n            tTextParam.b1            = FlashlightIsOn() ? 153 : 255;\n            tTextParam.a1            = 255;\n\n            tTextParam.r2            = FlashlightIsOn() ? 153 : 255;\n            tTextParam.g2            = FlashlightIsOn() ? 153 : 255;\n            tTextParam.b2            = FlashlightIsOn() ? 153 : 255;\n            tTextParam.a2            = 255;\n\n            tTextParam.fadeinTime    = 0;\n            tTextParam.fadeoutTime    = 0;\n\n            tTextParam.holdTime        = 4;\n            tTextParam.fxTime        = 0;\n            tTextParam.channel        = 1;\n\n            UTIL_HudMessage( this, tTextParam, &quot;Not enough points&quot; );\n\n            return false;\n        }\n    }\n\n    if ( points &gt;= pWeapon-&gt;GetPointCost() )\n    {\n        RemovePoints( pWeapon-&gt;GetPointCost() );\n        EmitSound( &quot;Door.Buy&quot; );\n\n        pWeapon-&gt;Respawn();\n        Weapon_Equip( pWeapon );\n\n        return true;\n    }else{\n        //error message\n\n        hudtextparms_s tTextParam;\n        tTextParam.x            = -1;\n        tTextParam.y            = 0.60;\n        tTextParam.effect        = 0;\n\n        tTextParam.r1            = FlashlightIsOn() ? 153 : 255;//153\n        tTextParam.g1            = FlashlightIsOn() ? 153 : 255;\n        tTextParam.b1            = FlashlightIsOn() ? 153 : 255;\n        tTextParam.a1            = 255;\n\n        tTextParam.r2            = FlashlightIsOn() ? 153 : 255;\n        tTextParam.g2            = FlashlightIsOn() ? 153 : 255;\n        tTextParam.b2            = FlashlightIsOn() ? 153 : 255;\n        tTextParam.a2            = 255;\n\n        tTextParam.fadeinTime    = 0;\n        tTextParam.fadeoutTime    = 0;\n\n        tTextParam.holdTime        = 4;\n        tTextParam.fxTime        = 0;\n        tTextParam.channel        = 1;\n\n        UTIL_HudMessage( this, tTextParam, &quot;Not enough points&quot; );\n\n        return false;\n    }\n\n    return false;\n}</code></pre>\n<p>I suggest handling messages better, probably in a new nicely animated HUD element. There&#39;s some more features but I&#39;ll save these for a third blog post, one of the things I wanted to talk about was the navmesh implementation that was used to replace the node system as I kept running into limitations in hammer.</p>\n"},"path":"blog/what-is-aftermath-2"}
