{"template":"../src/containers/Post","sharedHashesByProp":{},"data":{"title":"World Hints","slug":"world-hints","date":"2017-7-26","mins":17,"summary":"World hints are snippets of information in the level that help the user navigate or progress through the game. The one's I added to Resurgence used a specific font and had three sizes, they where placed in the level using a hammer entity and always faced the player.","contents":"<p>World hints are snippets of information in the level that help the user navigate or progress through the game. The one&#39;s I added to Resurgence used a specific font and had three sizes, they where placed in the level using a hammer entity and always faced the player which is called billboarding.</p>\n<p>So to implement this in your very own mod you first need to add the worldhint.cpp file for the server-side entity that&#39;s setup by hammer so that the level designer can create a worldhint entity with a font size, hint scale and the text for the hint itself.</p>\n<pre><code class=\"language-cpp\">#include &quot;cbase.h&quot;\n\nclass CWorldHint : public CBaseEntity\n{\npublic:\n    DECLARE_CLASS( CWorldHint, CBaseEntity );\n    DECLARE_SERVERCLASS();\n\n    CWorldHint();\n    void Spawn();\n    void Activate();\n\n    //Always send to all clients\n    int UpdateTransmitState()\n    {\n        return SetTransmitState( FL_EDICT_ALWAYS );\n    }\n\nprivate:\n    CNetworkString( hint, MAX_PATH );\n    CNetworkVar( int, fontSize );\n    CNetworkVar( float, scalar );\n\n    string_t m_String_tHint;\n\nprotected:\n    DECLARE_DATADESC();\n};\n\nLINK_ENTITY_TO_CLASS( worldhint, CWorldHint )\n\nBEGIN_DATADESC( CWorldHint )\n    DEFINE_KEYFIELD( m_String_tHint, FIELD_STRING, &quot;Hint&quot; ),\n    DEFINE_KEYFIELD( fontSize, FIELD_INTEGER, &quot;Size&quot; ),\n    DEFINE_KEYFIELD( scalar, FIELD_FLOAT, &quot;Scalar&quot; )\nEND_DATADESC()\n\nIMPLEMENT_SERVERCLASS_ST( CWorldHint, DT_WorldHint )\n    SendPropString( SENDINFO( hint ) ),\n    SendPropInt( SENDINFO( fontSize ) ),\n    SendPropFloat( SENDINFO( scalar ) ),\nEND_SEND_TABLE()\n\nCWorldHint::CWorldHint()\n{\n    fontSize = 1;\n    memset( hint.GetForModify(), 0, sizeof( hint ) );\n}\n\nvoid CWorldHint::Spawn()\n{\n    SetModelName( MAKE_STRING( &quot;worldhint&quot; ) );\n    SetSolid( SOLID_NONE );\n    SetMoveType( MOVETYPE_NONE );\n\n    Precache();\n    SetModel( STRING( GetModelName() ) );\n\n    AddEffects( EF_NOSHADOW | EF_NORECEIVESHADOW );\n}\n\nvoid CWorldHint::Activate()\n{\n    BaseClass::Activate();\n    Q_strncpy( hint.GetForModify(), STRING( m_String_tHint ), 255 );\n}</code></pre>\n<p>This is a pretty basic entity setup, the only special thing it does is copy the hint text from hammer to the variable used to send the info over to the client. It also completely hides itself as it&#39;s clientside only. This following server-side code is only 200 lines long and does the rest, first it creates a VGUI panel then sets up correct angles and world position and then proceeds to render the VGUI element in the world using the magic function called <a href=\"%22https://developer.valvesoftware.com/wiki/IMatSystemSurface%22\">DrawPanelIn3DSpace</a>.</p>\n<pre><code class=\"language-cpp\">#include &quot;cbase.h&quot;\n#include &quot;fmtstr.h&quot;\n\n//Vgui render stuff\n#include &quot;VGuiMatSurface/IMatSystemSurface.h&quot;\n#include &lt;vgui_controls/Panel.h&gt;\n#include &lt;vgui_controls/Label.h&gt;\n#include &lt;vgui/ISurface.h&gt;\n\n//Debugging\n#include &quot;debugoverlay_shared.h&quot;\n\n//\n//    Special hint panel used for drawing\n//\nclass HintPanel : public vgui::Panel\n{\npublic:\n    HintPanel( const char *text, int fontSize ) : fontSize( fontSize )\n    {\n        SetVisible( true );\n        SetPos( 0, 0 );\n\n        //Create basic label\n        label = new vgui::Label( this, &quot;&quot;, text );\n        label-&gt;SetPos( 0, 0 );\n    }\n\n    void ApplySchemeSettings( vgui::IScheme *pScheme )\n    {\n        //Get the font and set the label\n        vgui::HFont textFont = pScheme-&gt;GetFont( CFmtStr( &quot;WorldHint%i&quot;, fontSize ) );\n        label-&gt;SetFont( textFont );\n\n        //Get the labels text in wchar format\n        wchar_t wText[256];\n        label-&gt;GetText( wText, 256 );\n\n        //Calculate the texts size\n        int w, h;\n        vgui::surface()-&gt;GetTextSize( textFont, wText, w, h );\n\n        //Set the label and panels size to the texts size\n        label-&gt;SetSize( w, h );\n        SetSize( w, h );\n    }\n\nprivate:\n    vgui::Label *label;\n    int fontSize;\n};\n\nConVar res_debug_worldhint( &quot;res_debug_worldhint&quot;, &quot;0&quot; );\nConVar res_worldhint( &quot;res_worldhint&quot;, &quot;1&quot; );\n\n//\n//    Client-side worldhint entity for rendering the actual hint\n//\nclass C_WorldHint : public C_BaseEntity\n{\npublic:\n    DECLARE_CLASS( C_WorldHint, C_BaseEntity );\n    DECLARE_CLIENTCLASS();\n\n    C_WorldHint()\n    {\n        hintPanel = NULL;\n    }\n\n    virtual int DrawModel( int flags );\n    virtual void OnDataChanged( DataUpdateType_t type );\n\n    virtual void GetRenderBounds( Vector &amp;vecMins, Vector &amp;vecMaxs )\n    {\n        //Calculate the bounds for the hint\n        Vector half = Vector( width/2.0f, width/2.0f, height/2.0f );\n        vecMins.Init( -half.x, -half.y, -half.z );\n        vecMaxs.Init( half.x, half.y, half.z );\n\n        //Debug the bounds\n        if( res_debug_worldhint.GetBool() )\n            NDebugOverlay::Box( GetAbsOrigin(), vecMins, vecMaxs, 255, 0, 0, 128, 1.0f );\n    }\n\n    //Matrix stuff\n    void ComputePanelToWorld();\n    Vector CalculateOrigin( QAngle angles );\n    QAngle CalculateAngle();\n\nprivate:\n    char hint[MAX_PATH];\n    int fontSize;\n    float scalar;\n    VMatrix m_PanelToWorld;\n\n    //Panel stuff\n    float width, height;\n    int pWidth, pHeight;\n    HintPanel *hintPanel;\n};\n\nLINK_ENTITY_TO_CLASS( worldhint, C_WorldHint );\n\nIMPLEMENT_CLIENTCLASS_DT( C_WorldHint, DT_WorldHint, CWorldHint )\n    RecvPropString( RECVINFO( hint ) ),\n    RecvPropInt( RECVINFO( fontSize ) ),\n    RecvPropFloat( RECVINFO( scalar ) ),\nEND_RECV_TABLE()\n\nvoid C_WorldHint::OnDataChanged( DataUpdateType_t type )\n{\n    //We have some data to use\n    if( type == DATA_UPDATE_CREATED )\n    {\n        //Create the hint panel with our data\n        hintPanel = new HintPanel( hint, fontSize );\n        hintPanel-&gt;InvalidateLayout( true, true );//Setup scheme stuff\n        hintPanel-&gt;GetSize( pWidth, pHeight );\n\n        //\n        width = (float)pWidth/scalar;\n        height = (float)pHeight/scalar;\n    }\n\n    BaseClass::OnDataChanged( type );\n}\n\nVector C_WorldHint::CalculateOrigin( QAngle angles )\n{\n    Vector vecOrigin = GetAbsOrigin();\n\n    //Get the angle vectors\n    Vector xaxis, yaxis;\n    AngleVectors( angles, &amp;xaxis, &amp;yaxis, NULL );\n\n    //Transform the x and y axis to center it\n    VectorMA( vecOrigin, -(width/2), xaxis, vecOrigin );\n    VectorMA( vecOrigin, -(height/2), yaxis, vecOrigin );\n\n    //Return new origin\n    return vecOrigin;\n}\n\nQAngle C_WorldHint::CalculateAngle()\n{\n    //Get the player\n    C_BasePlayer *pLocalPlayer = C_BasePlayer::GetLocalPlayer();\n    if( !pLocalPlayer )\n        return vec3_angle;\n\n    //Get the direction between this and the player\n    Vector target = GetAbsOrigin()-(pLocalPlayer-&gt;GetAbsOrigin()+Vector(0,0,pLocalPlayer-&gt;GetPlayerMaxs().z/2));\n\n    //Convert to angles\n    QAngle angles;\n    VectorAngles( target, angles );\n\n    //Fix angles\n    angles[YAW] += 90;\n    angles[ROLL] = (-angles[PITCH])-90;\n    angles[PITCH] = 180;\n\n    //Return angles\n    return angles;\n}\n\nvoid C_WorldHint::ComputePanelToWorld()\n{\n    //Get out angle and origin\n    QAngle angles = CalculateAngle();\n    Vector origin = CalculateOrigin( angles );\n\n    //Set the matrix to them\n    m_PanelToWorld.SetupMatrixOrgAngles( origin, angles );\n\n    //Debug\n    if( res_debug_worldhint.GetBool() )\n    {\n        NDebugOverlay::Box( GetAbsOrigin(), Vector( -2,-2,-2 ), Vector( 2, 2, 2 ), 0, 255, 0, 255, 0.01f );\n        NDebugOverlay::Box( origin, Vector( -2,-2,-2 ), Vector( 2, 2, 2 ), 255, 0, 0, 255, 0.01f );\n    }\n}\n\nint C_WorldHint::DrawModel( int flags )\n{\n    //Client doesn&#39;t want to render these\n    if( !res_worldhint.GetBool() )\n        return 0;\n\n    //Wait for a panel to draw\n    if( !hintPanel )\n        return 0;\n\n    //Calculate the origin and angles\n    ComputePanelToWorld();\n\n    //Draw the panel\n    g_pMatSystemSurface-&gt;DrawPanelIn3DSpace( hintPanel-&gt;GetVPanel(), m_PanelToWorld, \n        pWidth, pHeight, width, height );\n\n    return 1;\n}</code></pre>\n<p>The source code is also available in this <a href=\"%22https://gist.github.com/tingtom/4b2240b1d681d1e59bdcd338b0823b91%22\">Gist</a>.</p>\n"},"path":"blog/world-hints"}
