{"template":"../src/containers/Post","sharedHashesByProp":{},"data":{"title":"HTML UI in Source SDK","slug":"html-ui-in-source","date":"2018-12-23T00:00:00.000Z","mins":7,"summary":"I always think I've reached the limits of the Source engine but I think I'm just not giving the engine enough credit, for Resurgence we keep messing around with the UI and one day I had an idea for using the HTML control for it which will allow it to be prototyped faster and allow non-programmers to provide a proper representation instead of an image.","contents":"<p>I always think I&#39;ve reached the limits of the Source engine but I think I&#39;m just not giving the engine enough credit, for Resurgence we keep messing around with the UI and one day I had an idea for using the HTML control for it which will allow it to be prototyped faster and allow non-programmers to provide a proper representation instead of an image.</p>\n<p>I had heard of awesomium but that&#39;s a bit messy and seems to be dead so I started with the HTML VGUI control which creates a CEF off-screen renderer for rendering and renders the result onto a VGUI panel, this was great as a starting point until I noticed a major issue when overriding the main menu VGUI element.</p>\n<h3 id=\"transparency\">Transparency</h3>\n<p>Resurgence has a cool main menu background map and for some reason Valve decided they didn&#39;t need transparency when rendering the HTML control, I poked around a bit and came to the conclusion that pretty much everything was in the chromehtml DLL and although the source is available I wasn&#39;t able to get it built with a old version of CEF.</p>\n<p>I didn&#39;t give up and instead had an idea to use a chroma key and set the background to green, this kinda worked but created issues for text and any transparency that we decided to use for the menu. I kept looking for a solution and while checking out the <a href=\"%22https://github.com/ValveSoftware/source-sdk-2013%22\">Source SDK Github</a> I noticed that the HTML control was slightly different to my version which was weird because Valve have pretty much abandoned it.. I compared the two and basically the off-screen renderer is now handled by the Steam client using the API so I copied over the required files for the HTML control and new Steam API code (which also requires new steam_api and steamvr DLLs) and the off-screen renderer was using a transparent background!</p>\n<h3 id=\"navigation\">Navigation</h3>\n<p>Now that the rendering was working and a HTML file was being loaded I began coding the menu flow and trying to figure out how the user will navigate around the menu. I didn&#39;t want a natural website with static HTML files because I wasn&#39;t sure how opening a bunch of HTML files would look or how fluid it would be so I poked around Javascript libraries and decided to use Vue and it&#39;s Router for navigation.</p>\n<p>The Vue router uses hashes to pretend to be a URL, hashes are normally used for anchors to scroll a user to a specific point but with Javascript you can dynamically set, read and react to hash changes so you can navigate to #/play and Vue will swap an entire section from the default component to another component setup when initialising Vue router with a transition.</p>\n<h3 id=\"data\">Data</h3>\n<p>Now that I had some kind of structure for the new menu I needed to get game data over to Vue and bind it for buttons, text and images. Communication from C++ to the off-screen renderer is very limited compared to if you setup CEF yourself but there&#39;s one function called &quot;ExecuteJavascript&quot; which does exactly what it says and allows you to send JS code.</p>\n<p>The best way would be to use a JSON library to create a structure and send it over once the HTML file has loaded to init Vue, the only issue is Source is pretty old and doesn&#39;t have a JSON library so after trying 3-4 different libs I ended up using <a href=\"%22http://rapidjson.org/%22\">RapidJSON</a> since most newer libs use features that the 2010 built tools don&#39;t support.</p>\n<p>The structure contained the different paths and content within the paths, each button either had a URL to another route or had a custom protocol (res://) that did something specific like loading a map or opening a Steam overlay URL which the mod would handle:</p>\n<pre><code class=\"language-cpp\">const char* url = data-&gt;GetString(&quot;url&quot;);\n\nCUtlVector&lt;char*, CUtlMemory&lt;char*, int&gt;&gt; strs;\nV_SplitString(url, &quot;/&quot;, strs);\nstrs.Remove(0);//remove &quot;res:&quot;\n\nif (strs.Count() &gt;= 0)\n{\n    if (strcmp(strs[0], &quot;menu&quot;) == 0)\n    {\n        char str[100];\n        Q_strncpy(str, &quot;gamemenucommand &quot;, sizeof(str));\n        Q_strncat(str, strs[1], sizeof(str), COPY_ALL_CHARACTERS);\n\n        engine-&gt;ClientCmd(str);\n    }\n    else if (strcmp(strs[0], &quot;command&quot;) == 0)\n    {\n        engine-&gt;ClientCmd(strs[1]);\n    }\n    else if (strcmp(strs[0], &quot;play&quot;) == 0)\n    {\n        g_pCVar-&gt;RevertFlaggedConVars(FCVAR_REPLICATED);\n        g_pCVar-&gt;RevertFlaggedConVars(FCVAR_CHEAT);\n\n        char szMapCommand[1024];\n        Q_snprintf(szMapCommand, sizeof(szMapCommand), &quot;disconnect\\nwait\\nwait\\nsv_lan 0\\nsetmaster enable\\nmaxplayers 1\\nhostname \\&quot;Game Name\\&quot;\\nprogress_enable\\nmap %s\\n&quot;, strs[1]);\n\n        // exec\n        engine-&gt;ClientCmd_Unrestricted(szMapCommand);\n    }\n    else if (strcmp(strs[0], &quot;achievements&quot;) == 0)\n        steamapicontext-&gt;SteamFriends()-&gt;ActivateGameOverlay(&quot;Achievements&quot;);\n}</code></pre>\n<h3 id=\"in-game-state\">In-game state</h3>\n<p>The menu is also used in game and since the UI is now custom the menu it looks exactly the same and needs to be reset when entering a level so I had to check for the engine-&gt;IsInGame() flag to see if it has changed and reset the HTML control and tell Vue to render some components differently, I ended up using the new map game event and navigating the page to root using the router like so:</p>\n<pre><code class=\"language-cpp\">void FireGameEvent(IGameEvent *event)\n{\n    if (strcmp(event-&gt;GetName(), &quot;game_newmap&quot;) != 0)\n        return;\n\n        ...\n\n    html-&gt;RunJavascript(&quot;navigateTo(&#39;/&#39;)&quot;);\n\n        ...\n}</code></pre>\n<p>As well as navigating back to home, the internal JS game data object is updated with an inGame flag so features such as changing the main menu can be achieved.</p>\n<h3 id=\"final-points\">Final points</h3>\n<p>I&#39;ve been slowly expanding the menu out to have difficulty selection, collectibles, loadout and want to move achievements to it. I also recently swapped to using webpack to compile all the vue components into 1-2 js files which is easier to deal with. Here&#39;s a video showing a bit of it:</p>\n<iframe style=\"display: block; margin-left: auto; margin-right: auto;max-width:560px\" src=\"https://www.youtube.com/embed/eyWjmHOO4ko\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"315\" frameborder=\"0\"></iframe>"},"path":"blog/html-ui-in-source"}
