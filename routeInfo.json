{"template":"../src/pages/index","sharedHashesByProp":{},"data":{"limitedPosts":[{"title":"Joystick trigger support in HL1","slug":"joystick","date":"2025-11-30T00:00:00.000Z","mins":2,"summary":"After releasing the demo for Half-Life Element 64 we had some people asking about controller support so I took a look.","contents":"<p>After releasing the demo for <a href=\"https://store.steampowered.com/app/1625220/HalfLife_Element_64/\">Half-Life: Element 64</a> we had some people asking about controller support so I took a look.</p>\n<h1 id=\"what-already-exists-\">What already exists?</h1>\n<p>Joystick support is already included in the better forks of the HL1 code base, we use the op4 base which added support of using SDL2 for finding joysticks. It still requires some setup in a config as there&#39;s no proper settings for them but once setup properly then it the movement seems ok.</p>\n<h1 id=\"what-s-missing-\">What&#39;s missing?</h1>\n<h2 id=\"there-s-no-trigger-support\">There&#39;s no trigger support</h2>\n<p>Triggers for modern controllers are they&#39;re own axis so they&#39;re not found as buttons for bindings, I added support for the left and right trigger axis to the code and spoofed them to trigger a button press if a threshold is met:</p>\n<p>Increase JOY_MAX_AXIS to 8 and add the new axis</p>\n<pre><code class=\"language-cpp\">#define JOY_MAX_AXES 8\n#define JOY_AXIS_TRIGGER_L 6\n#define JOY_AXIS_TRIGGER_R 7</code></pre>\n<p>in the RawValuePointer method add the new axis:</p>\n<pre><code class=\"language-cpp\">case JOY_AXIS_TRIGGER_L:\n    return SDL_GameControllerGetAxis(s_pJoystick, SDL_CONTROLLER_AXIS_TRIGGERLEFT);\ncase JOY_AXIS_TRIGGER_R:\n    return SDL_GameControllerGetAxis(s_pJoystick, SDL_CONTROLLER_AXIS_TRIGGERRIGHT);</code></pre>\n<p>in IN_JoyMove add the new axis:</p>\n<pre><code class=\"language-cpp\">// Turn trigger presses into key presses using a threshhold, use 31 and 32 due to not having engine access\nif (i == JOY_AXIS_TRIGGER_R)\n{\n    if (fabs(fAxisValue) &gt; joy_triggerrthreshold-&gt;value)\n    {\n        gEngfuncs.Key_Event(K_AUX31, 1);\n    }\n    else\n    {\n        gEngfuncs.Key_Event(K_AUX31, 0);\n    }\n}\nelse if (i == JOY_AXIS_TRIGGER_L)\n{\n    if (fabs(fAxisValue) &gt; joy_triggerlthreshold-&gt;value)\n    {\n        gEngfuncs.Key_Event(K_AUX32, 1);\n    }\n    else\n    {\n        gEngfuncs.Key_Event(K_AUX32, 0);\n    }\n}</code></pre>\n<p>K_AUX31 and K_AUX32 are used because they&#39;re the bottom of the list of what we can use, I tried adding new keys but the engine doesn&#39;t allow us so I had to use them instead.</p>\n<p>I added 2 new cvars for the threshold:</p>\n<pre><code class=\"language-cpp\">joy_triggerrthreshold = gEngfuncs.pfnRegisterVariable(&quot;joytriggerrthreshold&quot;, &quot;0.15&quot;, 0);\njoy_triggerlthreshold = gEngfuncs.pfnRegisterVariable(&quot;joytriggerlthreshold&quot;, &quot;0.15&quot;, 0);</code></pre>\n<p>Then aux32 and aux33 can then be bound like normal buttons to +attack or whatever.</p>\n<h2 id=\"menu-s-are-not-supported-in-keybindings\">Menu&#39;s are not supported in keybindings</h2>\n<p>The engine menu is not supported as a binding on it&#39;s own so I couldn&#39;t bind it to the start button on the controller, in IN_Commands I added some code like this:</p>\n<pre><code class=\"language-cpp\">// Correct key is pressed for joymenukey\nif (LookupJoyMenuKey(joy_menukey-&gt;string) == key_index + i)\n{\n    gEngfuncs.Key_Event(K_ESCAPE, 1);\n}</code></pre>\n<p>This gets the string from the joymenukey cvar and compares them and triggers the escape button on the engine side, this opens and closed the menu like normal. I originally added a normal concommand but the issue is the engine stops listening to button presses when the menu is open but I didn&#39;t want to have to put the controller down to close the menu.</p>\n<p>LookupJoyMenuKey is just a mapping from text to the K_ enum.</p>\n<h2 id=\"joysticks-are-not-picked-up-if-they-re-off\">Joysticks are not picked up if they&#39;re off</h2>\n<p>I noticed that if my controller was off and I opened the game then the controller isn&#39;t picked up, it was annoying so I added a small snippet to IN_JoyMove:</p>\n<pre><code class=\"language-cpp\">if (!joy_avail || 0 == in_joystick-&gt;value)\n{\n    // Check if the count has changed\n    int nJoysticks = SDL_NumJoysticks();\n\n    if (nJoysticks &gt; 0)\n    {\n        IN_StartupJoystick();\n    }\n\n    return;\n}</code></pre>\n"},{"title":"3d designing","slug":"3d-designing","date":"2025-11-29T00:00:00.000Z","mins":2,"summary":"I've been into 3d design and printing recently, I've been building a car from 1993 which means I'm missing some bits and some plastic bits have broken etc so I thought I'd start designing the replacements.","contents":"<p>I&#39;ve been into 3d design and printing recently, I&#39;ve been building a car from 1993 which means I&#39;m missing some bits and some plastic bits have broken etc so I thought I&#39;d start designing the replacements. I first got a 3d printer a few years ago, it was a ender 3 which is one of the most popular 3d printers, I called it Karen because it was painful to use and eventually I gave up on it as wanted too much attention and upgrades to keep it going.</p>\n<p>I now have a Bambu P1S which has been brilliant and would happily print anything I threw at it, including ABS and ASA which are the best filaments for car parts etc</p>\n<p>I&#39;ve been using Fusion 360 for my designing and have made quite a few models which have been pretty precise and fitted well, I&#39;ve setup a website for all things <a href=\"https://rx7.pro\">RX7</a> which has links to my Cults and Printables pages at the bottom.</p>\n"},{"title":"Grafana Beginnings","slug":"grafana-beginnings","date":"2020-05-02T00:00:00.000Z","mins":5,"summary":"After recently loosing a drive in my RAID array I decided it's probably a good idea to monitor my server.","contents":"<p>After recently loosing a drive in my RAID array I decided it&#39;s probably a good idea to monitor my server, my old server was a little HP ProLiant MicroServer Gen8 that was dual core and had 4gb (until I upgraded it to 8) and used to have an ELK stack running for log parsing and monitoring but it used way too much ram so had to be shutdown.</p>\n<p>My new server is a lot more powerful and is an enterprise Dell R610 so there&#39;s room for a monitoring container or 5!</p>\n<h2 id=\"hello-influxdb\">Hello InfluxDB</h2>\n<p>InfluxDB is a database built for time series so it&#39;s perfect for time based data.</p>\n<p>It also has a powerful query language with useful functions, Grafana provides a nice UI for building out the queries which I&#39;ve only had to not use once to build a custom query.</p>\n<p>Elasticsearch is very powerful and can also be used with Grafana but I decided against it due to resource issues still and it&#39;s not worth it for my medium sized server.</p>\n<h2 id=\"telegraf\">Telegraf</h2>\n<p>The ELK stack used Logstash to provide parsed data from logs to Elasticsearch which is what the L in ELK is.</p>\n<p>Telegraf is similar to the their Metricbeat &quot;plugin&quot;, it defines a bunch of inputs, outputs and processors in between. It has support for a lot of inputs by default, I haven&#39;t looked in to it yet but it looks simple enough to make a plugin using Go.</p>\n<p>By default it sends host information over to InfluxDB such as cpu, ram, disk usage, kernel information etc. Personally I enabled the &quot;docker&quot;, &quot;filecount&quot;, &quot;ipmi_sensor&quot;, &quot;snmp&quot;, &quot;snmp_trap&quot;, &quot;net&quot;, &quot;netstat&quot; and &quot;vsphere&quot; inputs.</p>\n<p>More to come on those inputs later.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>I&#39;m still playing around with Grafana and understanding everything it has to offer, I want to get more stats in to it from apps that are not supported in Telegraf but it&#39;s working well so far.</p>\n"},{"title":"Weapon script reloading in Source SDK","slug":"weapon-script-reload","date":"2019-12-13T00:00:00.000Z","mins":5,"summary":"In Source SDK you have to restart after editing a weapon script, this code will let you use a console command to reload the script of the current weapon after editing it","contents":"<p>In Source SDK you have to restart after editing a weapon script, this can be a pain when messing around with ammo or custom features you&#39;ve added. I&#39;m not 100% sure if everything works after reloading the script but it sure helps.</p>\n<p>First of all we&#39;re going to add a function called ReloadScheme to the basecombatweapon class so in basecombatweapon_shared.h add this in the public section:</p>\n<pre><code class=\"language-cpp\">virtual void ReloadScheme()\n{\n    ReadWeaponDataFromFileForSlot(filesystem, GetClassname(), &amp;m_hWeaponFileInfo, GetEncryptionKey(), true);\n}</code></pre>\n<p>also make sure this is at the top:</p>\n<pre><code class=\"language-cpp\">#include &quot;weapon_parse.h&quot;</code></pre>\n<p>in weapon_parse.h add a reset boolean to ReadWeaponDataFromFileForSlot like so:</p>\n<pre><code class=\"language-cpp\">// The weapon parse function\nbool ReadWeaponDataFromFileForSlot( IFileSystem* filesystem, const char *szWeaponName, \n    WEAPON_FILE_INFO_HANDLE *phandle, const unsigned char *pICEKey = NULL, bool reset = false );</code></pre>\n<p>then in the code for the function in weapon_parse.cpp add a check for the reset boolean:</p>\n<pre><code class=\"language-cpp\">if (reset)\n{\n    unsigned short lookup = m_WeaponInfoDatabase.Find(szWeaponName);\n    if (lookup != m_WeaponInfoDatabase.InvalidIndex())\n    {\n        delete m_WeaponInfoDatabase[lookup];\n        m_WeaponInfoDatabase.RemoveAt(lookup);\n    }\n}</code></pre>\n<p>under the return false at the top of the function. Then to wrap it all together add the console command to the top of the basecombatweapon_shared.cpp file within <code>#if !defined( CLIENT_DLL )</code></p>\n<pre><code class=\"language-cpp\">void CC_ReloadScript(void)\n{\n    CBasePlayer* pPlayer = UTIL_GetCommandClient();\n    if (pPlayer == NULL)\n        return;\n\n    CBaseCombatWeapon *pWeapon = pPlayer-&gt;GetActiveWeapon();\n    if (pWeapon == NULL)\n        return;\n\n    pWeapon-&gt;ReloadScheme();\n}\n\nstatic ConCommand weapon_reloadscript(&quot;weapon_reloadscript&quot;, CC_ReloadScript);</code></pre>\n"},{"title":"Player bleeding in Source SDK","slug":"bleeding-in-source","date":"2019-11-5","mins":12,"summary":"A random feature I added to a HL2MP mod was for the player to bleed for a bit after being shot, it uses HL2 particles to bleed from bullet holes for a specified amount of time.","contents":"<p>A random feature I added to a HL2MP mod was for the player to bleed for a bit after being shot, it uses HL2 particles to bleed from bullet holes for a specified amount of time. Here&#39;s how I did it:</p>\n<p>First we set up some variables in hl2mp_player.h</p>\n<pre><code class=\"language-cpp\">CNetworkVar( bool, m_bBleeding );\nVector bleedPos;\nVector bleedDir;\nfloat m_flBleedingTime;\nint bleedingAmount;</code></pre>\n<p>and then set the defaults for bleeding in hl2mp_player.cpp (Spawn function)</p>\n<pre><code class=\"language-cpp\">m_bBleeding = false;\nm_flBleedingTime = 0.0f;\nbleedingAmount = 0;</code></pre>\n<p>Still in hl2mp_player but in PostThink we do the actual bleeding based on these variables:</p>\n<pre><code class=\"language-cpp\">if( m_bBleeding &amp;&amp; bleedingAmount &gt; 0 &amp;&amp; m_flBleedingTime &lt; gpGlobals-&gt;curtime )\n{\n    //Bleed a little bit\n    TakeHealth( -1, DMG_GENERIC );\n\n    //Decrement\n    bleedingAmount--;\n    m_flBleedingTime = gpGlobals-&gt;curtime + BLEED_TIME;\n\n    //Finished bleeding\n    if( !bleedingAmount )\n        m_bBleeding = false;\n\n    //Spawn blood\n    UTIL_BloodSpray( bleedPos * GetAbsOrigin(), bleedDir, BloodColor(), bleedingAmount, FX_BLOODSPRAY_ALL );\n    UTIL_BloodDrips( bleedPos, bleedDir, BloodColor(), bleedingAmount );\n}</code></pre>\n<p>Now to actually start bleeding when damage is taken, so in OnTakeDamage we do this:</p>\n<pre><code class=\"language-cpp\">if( inputInfo.GetMaxDamage() != -1.0f )\n{\n    //Bleed!\n    m_bBleeding = true;\n    m_flBleedingTime = gpGlobals-&gt;curtime;\n    bleedingAmount = (int)ceil((float)inputInfo.GetDamage() / 5.0f);\n\n    Vector vecDir = vec3_origin;\n    if( inputInfo.GetInflictor() )\n    {\n        vecDir = inputInfo.GetInflictor()-&gt;WorldSpaceCenter() - Vector ( 0, 0, 10 ) - WorldSpaceCenter();\n        VectorNormalize( vecDir );\n    }\n\n    //Store last took damage\n    bleedPos = inputInfo.GetDamagePosition() / GetAbsOrigin();\n    bleedDir = vecDir;\n}</code></pre>\n<p>Here if the player is damaged we store the direction of the shot and calculate the position based on the offset on the players position. Now we need to network it so the player can see the blood on their end so we pop this in the send table as always:</p>\n<pre><code class=\"language-cpp\">SendPropBool( SENDINFO( m_bBleeding ) )</code></pre>\n<p>and add this to the recieve table in c_hl2mp_player.cpp:</p>\n<pre><code class=\"language-cpp\">RecvPropBool( RECVINFO( m_bBleeding ) )</code></pre>\n<p>and add two new variables to c_hl2mp_player.h:</p>\n<pre><code class=\"language-cpp\">//Bleeding\nbool m_bBleeding;\nfloat m_flTrailTime;</code></pre>\n<p>and set the defaults in Spawn (back in the cpp file) to this:</p>\n<pre><code class=\"language-cpp\">//Bleeding\nm_bBleeding = false;\nm_flTrailTime = 0.0f;</code></pre>\n<p>and now in ClientThink we do the bleeding for the local player!</p>\n<pre><code class=\"language-cpp\">//Bleed!\nif( m_bBleeding &amp;&amp; m_flTrailTime &lt; gpGlobals-&gt;curtime &amp;&amp; GetGroundEntity() )\n{\n    //Do a traceline from the player downwards\n    trace_t tr;\n    UTIL_TraceLine( GetAbsOrigin(), GetAbsOrigin()*Vector(0,0,-10), MASK_SOLID, this, COLLISION_GROUP_NONE, &amp;tr );\n\n    //Draw blood decal and increase time\n    UTIL_BloodDecalTrace( &amp;tr, BLOOD_COLOR_RED );\n    m_flTrailTime = gpGlobals-&gt;curtime+0.5f;\n}</code></pre>\n"},{"title":"Showing Legs in Source SDK","slug":"legs-in-source","date":"2019-08-05T00:00:00.000Z","mins":4,"summary":"An interesting addition to Aftermath was to show the legs of the player, each player could look down at their own player model which allowed each player to have a kind of representation in the game as they can see themselves and know which character they are","contents":"<p>An interesting addition to Aftermath was to show the legs of the player, each player could look down at their own player model which allowed each player to have a kind of representation in the game as they can see themselves and know which character they are.</p>\n<p>This post will be for singleplayer as this is the latest example I have but multiplayer should be similar since it&#39;s only client side code. All the code is in c_baseplayer.cpp &amp; h, first you make sure the model is set for the player:</p>\n<pre><code class=\"language-cpp\">void C_BasePlayer::Spawn( void )\n{\n    SetModel( &quot;models/myplayermodel/playermodel.mdl&quot; );\n}</code></pre>\n<p>This is because the legs come from the player model and the default has no animations and will not look great, next we&#39;ll move the model back so the camera doesn&#39;t clip with the camera.</p>\n<pre><code class=\"language-cpp\">const Vector&amp; C_BasePlayer::GetRenderOrigin( void )\n{\n    //Dont apply in thirdperson\n    if( IsLocalPlayer() &amp;&amp; !input-&gt;CAM_IsThirdPerson() )\n    {\n        static Vector forward;\n        AngleVectors( GetRenderAngles(), &amp;forward );\n\n        // Shift the render origin by a fixed amount\n        forward *= -25;\n        forward += GetAbsOrigin();\n\n        return forward;\n    }else{\n        return BaseClass::GetRenderOrigin();\n    }\n}</code></pre>\n<p>Here we determine the forward position (if we&#39;re not in thirdperson) and use it to change the render origin of the model back a bit, you can change 25 to whatever you want or even use a convar and test it in game.</p>\n<pre><code class=\"language-cpp\">ConVar cl_legs( &quot;cl_legs&quot;, &quot;1&quot;, 0, &quot;Enable or disable player leg rendering&quot;, true, 0, true, 1 );\n\nint C_BasePlayer::DrawModel( int flags )\n{\n    //Ignore if the convar is enabled\n    if( !cl_legs.GetBool() )\n        return 0;\n\n    CMatRenderContextPtr context(materials);\n\n    //Don&#39;t render above a certain height of the body\n    if ( IsLocalPlayer() &amp;&amp; !input-&gt;CAM_IsThirdPerson() )\n    {\n        if ( (GetFlags() &amp; FL_DUCKING) || m_Local.m_bDucking )\n        {\n            context-&gt;SetHeightClipMode(MATERIAL_HEIGHTCLIPMODE_RENDER_BELOW_HEIGHT);\n            context-&gt;SetHeightClipZ(GetAbsOrigin().z+27);\n        }else{\n            context-&gt;SetHeightClipMode(MATERIAL_HEIGHTCLIPMODE_RENDER_BELOW_HEIGHT);\n            context-&gt;SetHeightClipZ(GetAbsOrigin().z+50);\n        }\n    }\n\n    //Draw the model\n    int nDrawRes = BaseClass::DrawModel(flags);\n\n    // Remove height clipping\n    context-&gt;SetHeightClipMode(MATERIAL_HEIGHTCLIPMODE_DISABLE);\n\n    return nDrawRes;\n}</code></pre>\n<p>Here we clip the player model to remove the upperbody and even lower if the player is ducking, there&#39;s also a convar for disabling the legs.</p>\n<p>That&#39;s pretty much it, if you have access to the player models another option is to create a bodygroup and disable several parts of the body as you see fit but this is the easiest option.</p>\n"}],"limitedProjects":[{"title":"Untitled Cat Game","slug":"ucg","summary":null,"image":"ucg.png","homepage":true,"contents":"<p>I&#39;ve always wanted to make a game that was cat related so I&#39;m working on something in Godot, I&#39;m trying to keep it simple but I always scope creep.. it&#39;s going to be a cat fighting game and in 3d with a top down angled camera.</p>\n<p>The idea is to be mostly physics based with some fun mechanics.</p>\n"},{"title":"Half-Life: Element 64","slug":"hle64","summary":null,"image":"hle.jpg","homepage":true,"contents":"<p>Half Life: Element 64 is a HL1 mod that is designed to feel like the a classic FPS, this is the official blurb:</p>\n<p>&quot;While CRT monitors, floopy disks and GSM cell phones are still hot, the world has to face an alien threat from dimension unknown. Black Mesa Research Facility is breached and only one man can save the human race from extinction. Step up to the task, load your shotgun and save the universe in this adventure inspired by classic first-person shooters of 1990s!&quot;</p>\n<p><a href=\"https://store.steampowered.com/app/1625220/HalfLife_Element_64\">https://store.steampowered.com/app/1625220/HalfLife_Element_64</a></p>\n"},{"title":"Resurgence","slug":"resurgence","summary":"Resurgence deploys you in shoes of a young resistance member, who have escaped from Nova Prospekt thanks to one free man, and is willing to find his old friends in order to reunite and fight together for the future of the human race.","image":"res.png","homepage":true,"contents":"<p>Resurgence deploys you in shoes of a young resistance member, who have escaped from Nova Prospekt thanks to one free man, and is willing to find his old friends in order to reunite and fight together for the future of the human race. Arrive at City 37 to help regain the throne from the falling empire of Combine and bring back the world we all knew at one point.</p>\n"},{"title":"Aftermath","slug":"aftermath","summary":"Aftermath also known as Aftermath:Source and initally Zombie Survival is a HL2 mod created using C++ on the Source engine.","image":"aftermath.png","homepage":true,"contents":"<p>Aftermath also known as Aftermath:Source and initally Zombie Survival is a HL2 mod created using C++ on the Source engine. It began when I decided to create a game similar to Call of Duty&#39;s Zombies mode as I enjoyed playing it and wanted to create something similar, this began with trying to replicate various gameplay features but ended with some custom features to try and seperate itself from the franchise.</p>\n"}]},"path":"/"}
