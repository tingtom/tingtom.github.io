{"template":"../src/pages/index","sharedHashesByProp":{},"data":{"limitedPosts":[{"title":"3d designing","slug":"3d-designing","date":"2025-11-29T00:00:00.000Z","mins":2,"summary":"I've been into 3d design and printing recently, I've been building a car from 1993 which means I'm missing some bits and some plastic bits have broken etc so I thought I'd start designing the replacements.","contents":"<p>I&#39;ve been into 3d design and printing recently, I&#39;ve been building a car from 1993 which means I&#39;m missing some bits and some plastic bits have broken etc so I thought I&#39;d start designing the replacements. I first got a 3d printer a few years ago, it was a ender 3 which is one of the most popular 3d printers, I called it Karen because it was painful to use and eventually I gave up on it as wanted too much attention and upgrades to keep it going.</p>\n<p>I now have a Bambu P1S which has been brilliant and would happily print anything I threw at it, including ABS and ASA which are the best filaments for car parts etc</p>\n<p>I&#39;ve been using Fusion 360 for my designing and have made quite a few models which have been pretty precise and fitted well, I&#39;ve setup a website for all things <a href=\"https://rx7.pro\">RX7</a> which has links to my Cults and Printables pages at the bottom.</p>\n"},{"title":"Grafana Beginnings","slug":"grafana-beginnings","date":"2020-05-02T00:00:00.000Z","mins":5,"summary":"After recently loosing a drive in my RAID array I decided it's probably a good idea to monitor my server.","contents":"<p>After recently loosing a drive in my RAID array I decided it&#39;s probably a good idea to monitor my server, my old server was a little HP ProLiant MicroServer Gen8 that was dual core and had 4gb (until I upgraded it to 8) and used to have an ELK stack running for log parsing and monitoring but it used way too much ram so had to be shutdown.</p>\n<p>My new server is a lot more powerful and is an enterprise Dell R610 so there&#39;s room for a monitoring container or 5!</p>\n<h2 id=\"hello-influxdb\">Hello InfluxDB</h2>\n<p>InfluxDB is a database built for time series so it&#39;s perfect for time based data.</p>\n<p>It also has a powerful query language with useful functions, Grafana provides a nice UI for building out the queries which I&#39;ve only had to not use once to build a custom query.</p>\n<p>Elasticsearch is very powerful and can also be used with Grafana but I decided against it due to resource issues still and it&#39;s not worth it for my medium sized server.</p>\n<h2 id=\"telegraf\">Telegraf</h2>\n<p>The ELK stack used Logstash to provide parsed data from logs to Elasticsearch which is what the L in ELK is.</p>\n<p>Telegraf is similar to the their Metricbeat &quot;plugin&quot;, it defines a bunch of inputs, outputs and processors in between. It has support for a lot of inputs by default, I haven&#39;t looked in to it yet but it looks simple enough to make a plugin using Go.</p>\n<p>By default it sends host information over to InfluxDB such as cpu, ram, disk usage, kernel information etc. Personally I enabled the &quot;docker&quot;, &quot;filecount&quot;, &quot;ipmi_sensor&quot;, &quot;snmp&quot;, &quot;snmp_trap&quot;, &quot;net&quot;, &quot;netstat&quot; and &quot;vsphere&quot; inputs.</p>\n<p>More to come on those inputs later.</p>\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>I&#39;m still playing around with Grafana and understanding everything it has to offer, I want to get more stats in to it from apps that are not supported in Telegraf but it&#39;s working well so far.</p>\n"},{"title":"Weapon script reloading in Source SDK","slug":"weapon-script-reload","date":"2019-12-13T00:00:00.000Z","mins":5,"summary":"In Source SDK you have to restart after editing a weapon script, this code will let you use a console command to reload the script of the current weapon after editing it","contents":"<p>In Source SDK you have to restart after editing a weapon script, this can be a pain when messing around with ammo or custom features you&#39;ve added. I&#39;m not 100% sure if everything works after reloading the script but it sure helps.</p>\n<p>First of all we&#39;re going to add a function called ReloadScheme to the basecombatweapon class so in basecombatweapon_shared.h add this in the public section:</p>\n<pre><code class=\"language-cpp\">virtual void ReloadScheme()\n{\n    ReadWeaponDataFromFileForSlot(filesystem, GetClassname(), &amp;m_hWeaponFileInfo, GetEncryptionKey(), true);\n}</code></pre>\n<p>also make sure this is at the top:</p>\n<pre><code class=\"language-cpp\">#include &quot;weapon_parse.h&quot;</code></pre>\n<p>in weapon_parse.h add a reset boolean to ReadWeaponDataFromFileForSlot like so:</p>\n<pre><code class=\"language-cpp\">// The weapon parse function\nbool ReadWeaponDataFromFileForSlot( IFileSystem* filesystem, const char *szWeaponName, \n    WEAPON_FILE_INFO_HANDLE *phandle, const unsigned char *pICEKey = NULL, bool reset = false );</code></pre>\n<p>then in the code for the function in weapon_parse.cpp add a check for the reset boolean:</p>\n<pre><code class=\"language-cpp\">if (reset)\n{\n    unsigned short lookup = m_WeaponInfoDatabase.Find(szWeaponName);\n    if (lookup != m_WeaponInfoDatabase.InvalidIndex())\n    {\n        delete m_WeaponInfoDatabase[lookup];\n        m_WeaponInfoDatabase.RemoveAt(lookup);\n    }\n}</code></pre>\n<p>under the return false at the top of the function. Then to wrap it all together add the console command to the top of the basecombatweapon_shared.cpp file within <code>#if !defined( CLIENT_DLL )</code></p>\n<pre><code class=\"language-cpp\">void CC_ReloadScript(void)\n{\n    CBasePlayer* pPlayer = UTIL_GetCommandClient();\n    if (pPlayer == NULL)\n        return;\n\n    CBaseCombatWeapon *pWeapon = pPlayer-&gt;GetActiveWeapon();\n    if (pWeapon == NULL)\n        return;\n\n    pWeapon-&gt;ReloadScheme();\n}\n\nstatic ConCommand weapon_reloadscript(&quot;weapon_reloadscript&quot;, CC_ReloadScript);</code></pre>\n"},{"title":"Player bleeding in Source SDK","slug":"bleeding-in-source","date":"2019-11-5","mins":12,"summary":"A random feature I added to a HL2MP mod was for the player to bleed for a bit after being shot, it uses HL2 particles to bleed from bullet holes for a specified amount of time.","contents":"<p>A random feature I added to a HL2MP mod was for the player to bleed for a bit after being shot, it uses HL2 particles to bleed from bullet holes for a specified amount of time. Here&#39;s how I did it:</p>\n<p>First we set up some variables in hl2mp_player.h</p>\n<pre><code class=\"language-cpp\">CNetworkVar( bool, m_bBleeding );\nVector bleedPos;\nVector bleedDir;\nfloat m_flBleedingTime;\nint bleedingAmount;</code></pre>\n<p>and then set the defaults for bleeding in hl2mp_player.cpp (Spawn function)</p>\n<pre><code class=\"language-cpp\">m_bBleeding = false;\nm_flBleedingTime = 0.0f;\nbleedingAmount = 0;</code></pre>\n<p>Still in hl2mp_player but in PostThink we do the actual bleeding based on these variables:</p>\n<pre><code class=\"language-cpp\">if( m_bBleeding &amp;&amp; bleedingAmount &gt; 0 &amp;&amp; m_flBleedingTime &lt; gpGlobals-&gt;curtime )\n{\n    //Bleed a little bit\n    TakeHealth( -1, DMG_GENERIC );\n\n    //Decrement\n    bleedingAmount--;\n    m_flBleedingTime = gpGlobals-&gt;curtime + BLEED_TIME;\n\n    //Finished bleeding\n    if( !bleedingAmount )\n        m_bBleeding = false;\n\n    //Spawn blood\n    UTIL_BloodSpray( bleedPos * GetAbsOrigin(), bleedDir, BloodColor(), bleedingAmount, FX_BLOODSPRAY_ALL );\n    UTIL_BloodDrips( bleedPos, bleedDir, BloodColor(), bleedingAmount );\n}</code></pre>\n<p>Now to actually start bleeding when damage is taken, so in OnTakeDamage we do this:</p>\n<pre><code class=\"language-cpp\">if( inputInfo.GetMaxDamage() != -1.0f )\n{\n    //Bleed!\n    m_bBleeding = true;\n    m_flBleedingTime = gpGlobals-&gt;curtime;\n    bleedingAmount = (int)ceil((float)inputInfo.GetDamage() / 5.0f);\n\n    Vector vecDir = vec3_origin;\n    if( inputInfo.GetInflictor() )\n    {\n        vecDir = inputInfo.GetInflictor()-&gt;WorldSpaceCenter() - Vector ( 0, 0, 10 ) - WorldSpaceCenter();\n        VectorNormalize( vecDir );\n    }\n\n    //Store last took damage\n    bleedPos = inputInfo.GetDamagePosition() / GetAbsOrigin();\n    bleedDir = vecDir;\n}</code></pre>\n<p>Here if the player is damaged we store the direction of the shot and calculate the position based on the offset on the players position. Now we need to network it so the player can see the blood on their end so we pop this in the send table as always:</p>\n<pre><code class=\"language-cpp\">SendPropBool( SENDINFO( m_bBleeding ) )</code></pre>\n<p>and add this to the recieve table in c_hl2mp_player.cpp:</p>\n<pre><code class=\"language-cpp\">RecvPropBool( RECVINFO( m_bBleeding ) )</code></pre>\n<p>and add two new variables to c_hl2mp_player.h:</p>\n<pre><code class=\"language-cpp\">//Bleeding\nbool m_bBleeding;\nfloat m_flTrailTime;</code></pre>\n<p>and set the defaults in Spawn (back in the cpp file) to this:</p>\n<pre><code class=\"language-cpp\">//Bleeding\nm_bBleeding = false;\nm_flTrailTime = 0.0f;</code></pre>\n<p>and now in ClientThink we do the bleeding for the local player!</p>\n<pre><code class=\"language-cpp\">//Bleed!\nif( m_bBleeding &amp;&amp; m_flTrailTime &lt; gpGlobals-&gt;curtime &amp;&amp; GetGroundEntity() )\n{\n    //Do a traceline from the player downwards\n    trace_t tr;\n    UTIL_TraceLine( GetAbsOrigin(), GetAbsOrigin()*Vector(0,0,-10), MASK_SOLID, this, COLLISION_GROUP_NONE, &amp;tr );\n\n    //Draw blood decal and increase time\n    UTIL_BloodDecalTrace( &amp;tr, BLOOD_COLOR_RED );\n    m_flTrailTime = gpGlobals-&gt;curtime+0.5f;\n}</code></pre>\n"},{"title":"Showing Legs in Source SDK","slug":"legs-in-source","date":"2019-08-05T00:00:00.000Z","mins":4,"summary":"An interesting addition to Aftermath was to show the legs of the player, each player could look down at their own player model which allowed each player to have a kind of representation in the game as they can see themselves and know which character they are","contents":"<p>An interesting addition to Aftermath was to show the legs of the player, each player could look down at their own player model which allowed each player to have a kind of representation in the game as they can see themselves and know which character they are.</p>\n<p>This post will be for singleplayer as this is the latest example I have but multiplayer should be similar since it&#39;s only client side code. All the code is in c_baseplayer.cpp &amp; h, first you make sure the model is set for the player:</p>\n<pre><code class=\"language-cpp\">void C_BasePlayer::Spawn( void )\n{\n    SetModel( &quot;models/myplayermodel/playermodel.mdl&quot; );\n}</code></pre>\n<p>This is because the legs come from the player model and the default has no animations and will not look great, next we&#39;ll move the model back so the camera doesn&#39;t clip with the camera.</p>\n<pre><code class=\"language-cpp\">const Vector&amp; C_BasePlayer::GetRenderOrigin( void )\n{\n    //Dont apply in thirdperson\n    if( IsLocalPlayer() &amp;&amp; !input-&gt;CAM_IsThirdPerson() )\n    {\n        static Vector forward;\n        AngleVectors( GetRenderAngles(), &amp;forward );\n\n        // Shift the render origin by a fixed amount\n        forward *= -25;\n        forward += GetAbsOrigin();\n\n        return forward;\n    }else{\n        return BaseClass::GetRenderOrigin();\n    }\n}</code></pre>\n<p>Here we determine the forward position (if we&#39;re not in thirdperson) and use it to change the render origin of the model back a bit, you can change 25 to whatever you want or even use a convar and test it in game.</p>\n<pre><code class=\"language-cpp\">ConVar cl_legs( &quot;cl_legs&quot;, &quot;1&quot;, 0, &quot;Enable or disable player leg rendering&quot;, true, 0, true, 1 );\n\nint C_BasePlayer::DrawModel( int flags )\n{\n    //Ignore if the convar is enabled\n    if( !cl_legs.GetBool() )\n        return 0;\n\n    CMatRenderContextPtr context(materials);\n\n    //Don&#39;t render above a certain height of the body\n    if ( IsLocalPlayer() &amp;&amp; !input-&gt;CAM_IsThirdPerson() )\n    {\n        if ( (GetFlags() &amp; FL_DUCKING) || m_Local.m_bDucking )\n        {\n            context-&gt;SetHeightClipMode(MATERIAL_HEIGHTCLIPMODE_RENDER_BELOW_HEIGHT);\n            context-&gt;SetHeightClipZ(GetAbsOrigin().z+27);\n        }else{\n            context-&gt;SetHeightClipMode(MATERIAL_HEIGHTCLIPMODE_RENDER_BELOW_HEIGHT);\n            context-&gt;SetHeightClipZ(GetAbsOrigin().z+50);\n        }\n    }\n\n    //Draw the model\n    int nDrawRes = BaseClass::DrawModel(flags);\n\n    // Remove height clipping\n    context-&gt;SetHeightClipMode(MATERIAL_HEIGHTCLIPMODE_DISABLE);\n\n    return nDrawRes;\n}</code></pre>\n<p>Here we clip the player model to remove the upperbody and even lower if the player is ducking, there&#39;s also a convar for disabling the legs.</p>\n<p>That&#39;s pretty much it, if you have access to the player models another option is to create a bodygroup and disable several parts of the body as you see fit but this is the easiest option.</p>\n"},{"title":"HTML UI in Source SDK","slug":"html-ui-in-source","date":"2018-12-23T00:00:00.000Z","mins":7,"summary":"I always think I've reached the limits of the Source engine but I think I'm just not giving the engine enough credit, for Resurgence we keep messing around with the UI and one day I had an idea for using the HTML control for it which will allow it to be prototyped faster and allow non-programmers to provide a proper representation instead of an image.","contents":"<p>I always think I&#39;ve reached the limits of the Source engine but I think I&#39;m just not giving the engine enough credit, for Resurgence we keep messing around with the UI and one day I had an idea for using the HTML control for it which will allow it to be prototyped faster and allow non-programmers to provide a proper representation instead of an image.</p>\n<p>I had heard of awesomium but that&#39;s a bit messy and seems to be dead so I started with the HTML VGUI control which creates a CEF off-screen renderer for rendering and renders the result onto a VGUI panel, this was great as a starting point until I noticed a major issue when overriding the main menu VGUI element.</p>\n<h3 id=\"transparency\">Transparency</h3>\n<p>Resurgence has a cool main menu background map and for some reason Valve decided they didn&#39;t need transparency when rendering the HTML control, I poked around a bit and came to the conclusion that pretty much everything was in the chromehtml DLL and although the source is available I wasn&#39;t able to get it built with a old version of CEF.</p>\n<p>I didn&#39;t give up and instead had an idea to use a chroma key and set the background to green, this kinda worked but created issues for text and any transparency that we decided to use for the menu. I kept looking for a solution and while checking out the <a href=\"%22https://github.com/ValveSoftware/source-sdk-2013%22\">Source SDK Github</a> I noticed that the HTML control was slightly different to my version which was weird because Valve have pretty much abandoned it.. I compared the two and basically the off-screen renderer is now handled by the Steam client using the API so I copied over the required files for the HTML control and new Steam API code (which also requires new steam_api and steamvr DLLs) and the off-screen renderer was using a transparent background!</p>\n<h3 id=\"navigation\">Navigation</h3>\n<p>Now that the rendering was working and a HTML file was being loaded I began coding the menu flow and trying to figure out how the user will navigate around the menu. I didn&#39;t want a natural website with static HTML files because I wasn&#39;t sure how opening a bunch of HTML files would look or how fluid it would be so I poked around Javascript libraries and decided to use Vue and it&#39;s Router for navigation.</p>\n<p>The Vue router uses hashes to pretend to be a URL, hashes are normally used for anchors to scroll a user to a specific point but with Javascript you can dynamically set, read and react to hash changes so you can navigate to #/play and Vue will swap an entire section from the default component to another component setup when initialising Vue router with a transition.</p>\n<h3 id=\"data\">Data</h3>\n<p>Now that I had some kind of structure for the new menu I needed to get game data over to Vue and bind it for buttons, text and images. Communication from C++ to the off-screen renderer is very limited compared to if you setup CEF yourself but there&#39;s one function called &quot;ExecuteJavascript&quot; which does exactly what it says and allows you to send JS code.</p>\n<p>The best way would be to use a JSON library to create a structure and send it over once the HTML file has loaded to init Vue, the only issue is Source is pretty old and doesn&#39;t have a JSON library so after trying 3-4 different libs I ended up using <a href=\"%22http://rapidjson.org/%22\">RapidJSON</a> since most newer libs use features that the 2010 built tools don&#39;t support.</p>\n<p>The structure contained the different paths and content within the paths, each button either had a URL to another route or had a custom protocol (res://) that did something specific like loading a map or opening a Steam overlay URL which the mod would handle:</p>\n<pre><code class=\"language-cpp\">const char* url = data-&gt;GetString(&quot;url&quot;);\n\nCUtlVector&lt;char*, CUtlMemory&lt;char*, int&gt;&gt; strs;\nV_SplitString(url, &quot;/&quot;, strs);\nstrs.Remove(0);//remove &quot;res:&quot;\n\nif (strs.Count() &gt;= 0)\n{\n    if (strcmp(strs[0], &quot;menu&quot;) == 0)\n    {\n        char str[100];\n        Q_strncpy(str, &quot;gamemenucommand &quot;, sizeof(str));\n        Q_strncat(str, strs[1], sizeof(str), COPY_ALL_CHARACTERS);\n\n        engine-&gt;ClientCmd(str);\n    }\n    else if (strcmp(strs[0], &quot;command&quot;) == 0)\n    {\n        engine-&gt;ClientCmd(strs[1]);\n    }\n    else if (strcmp(strs[0], &quot;play&quot;) == 0)\n    {\n        g_pCVar-&gt;RevertFlaggedConVars(FCVAR_REPLICATED);\n        g_pCVar-&gt;RevertFlaggedConVars(FCVAR_CHEAT);\n\n        char szMapCommand[1024];\n        Q_snprintf(szMapCommand, sizeof(szMapCommand), &quot;disconnect\\nwait\\nwait\\nsv_lan 0\\nsetmaster enable\\nmaxplayers 1\\nhostname \\&quot;Game Name\\&quot;\\nprogress_enable\\nmap %s\\n&quot;, strs[1]);\n\n        // exec\n        engine-&gt;ClientCmd_Unrestricted(szMapCommand);\n    }\n    else if (strcmp(strs[0], &quot;achievements&quot;) == 0)\n        steamapicontext-&gt;SteamFriends()-&gt;ActivateGameOverlay(&quot;Achievements&quot;);\n}</code></pre>\n<h3 id=\"in-game-state\">In-game state</h3>\n<p>The menu is also used in game and since the UI is now custom the menu it looks exactly the same and needs to be reset when entering a level so I had to check for the engine-&gt;IsInGame() flag to see if it has changed and reset the HTML control and tell Vue to render some components differently, I ended up using the new map game event and navigating the page to root using the router like so:</p>\n<pre><code class=\"language-cpp\">void FireGameEvent(IGameEvent *event)\n{\n    if (strcmp(event-&gt;GetName(), &quot;game_newmap&quot;) != 0)\n        return;\n\n        ...\n\n    html-&gt;RunJavascript(&quot;navigateTo(&#39;/&#39;)&quot;);\n\n        ...\n}</code></pre>\n<p>As well as navigating back to home, the internal JS game data object is updated with an inGame flag so features such as changing the main menu can be achieved.</p>\n<h3 id=\"final-points\">Final points</h3>\n<p>I&#39;ve been slowly expanding the menu out to have difficulty selection, collectibles, loadout and want to move achievements to it. I also recently swapped to using webpack to compile all the vue components into 1-2 js files which is easier to deal with. Here&#39;s a video showing a bit of it:</p>\n<iframe style=\"display: block; margin-left: auto; margin-right: auto;max-width:560px\" src=\"https://www.youtube.com/embed/eyWjmHOO4ko\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"315\" frameborder=\"0\"></iframe>"}],"limitedProjects":[{"title":"Half-Life: Element 64","slug":"hle64","summary":null,"image":"hle.jpg","homepage":true,"contents":"<p>Half Life: Element 64 is a HL1 mod that is designed to feel like the a classic FPS, this is the official blurb:</p>\n<p>&quot;While CRT monitors, floopy disks and GSM cell phones are still hot, the world has to face an alien threat from dimension unknown. Black Mesa Research Facility is breached and only one man can save the human race from extinction. Step up to the task, load your shotgun and save the universe in this adventure inspired by classic first-person shooters of 1990s!&quot;</p>\n<p><a href=\"https://store.steampowered.com/app/1625220/HalfLife_Element_64\">https://store.steampowered.com/app/1625220/HalfLife_Element_64</a></p>\n"},{"title":"Untitled Cat Game","slug":"ucg","summary":null,"image":"ucg.png","homepage":true,"contents":"<p>I&#39;ve always wanted to make a game that was cat related so I&#39;m working on something in Godot, I&#39;m trying to keep it simple but I always scope creep.. it&#39;s going to be a cat fighting game and in 3d with a top down angled camera.</p>\n<p>The idea is to be mostly physics based with some fun mechanics.</p>\n"},{"title":"Resurgence","slug":"resurgence","summary":"Resurgence deploys you in shoes of a young resistance member, who have escaped from Nova Prospekt thanks to one free man, and is willing to find his old friends in order to reunite and fight together for the future of the human race.","image":"res.png","homepage":true,"contents":"<p>Resurgence deploys you in shoes of a young resistance member, who have escaped from Nova Prospekt thanks to one free man, and is willing to find his old friends in order to reunite and fight together for the future of the human race. Arrive at City 37 to help regain the throne from the falling empire of Combine and bring back the world we all knew at one point.</p>\n"},{"title":"Aftermath","slug":"aftermath","summary":"Aftermath also known as Aftermath:Source and initally Zombie Survival is a HL2 mod created using C++ on the Source engine.","image":"aftermath.png","homepage":true,"contents":"<p>Aftermath also known as Aftermath:Source and initally Zombie Survival is a HL2 mod created using C++ on the Source engine. It began when I decided to create a game similar to Call of Duty&#39;s Zombies mode as I enjoyed playing it and wanted to create something similar, this began with trying to replicate various gameplay features but ended with some custom features to try and seperate itself from the franchise.</p>\n"}]},"path":"/"}
