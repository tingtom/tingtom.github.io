{"template":"../src/pages/index","sharedHashesByProp":{},"data":{"limitedPosts":[{"title":"Weapon script reloading in Source SDK","slug":"weapon-script-reload","date":"2019-12-13T00:00:00.000Z","mins":5,"summary":"In Source SDK you have to restart after editing a weapon script, this code will let you use a console command to reload the script of the current weapon after editing it","contents":"<p>In Source SDK you have to restart after editing a weapon script, this can be a pain when messing around with ammo or custom features you&#39;ve added. I&#39;m not 100% sure if everything works after reloading the script but it sure helps.</p>\n<p>First of all we&#39;re going to add a function called ReloadScheme to the basecombatweapon class so in basecombatweapon_shared.h add this in the public section:</p>\n<pre><code class=\"language-cpp\">virtual void ReloadScheme()\n{\n    ReadWeaponDataFromFileForSlot(filesystem, GetClassname(), &amp;m_hWeaponFileInfo, GetEncryptionKey(), true);\n}</code></pre>\n<p>also make sure this is at the top:</p>\n<pre><code class=\"language-cpp\">#include &quot;weapon_parse.h&quot;</code></pre>\n<p>in weapon_parse.h add a reset boolean to ReadWeaponDataFromFileForSlot like so:</p>\n<pre><code class=\"language-cpp\">// The weapon parse function\nbool ReadWeaponDataFromFileForSlot( IFileSystem* filesystem, const char *szWeaponName, \n    WEAPON_FILE_INFO_HANDLE *phandle, const unsigned char *pICEKey = NULL, bool reset = false );</code></pre>\n<p>then in the code for the function in weapon_parse.cpp add a check for the reset boolean:</p>\n<pre><code class=\"language-cpp\">if (reset)\n{\n    unsigned short lookup = m_WeaponInfoDatabase.Find(szWeaponName);\n    if (lookup != m_WeaponInfoDatabase.InvalidIndex())\n    {\n        delete m_WeaponInfoDatabase[lookup];\n        m_WeaponInfoDatabase.RemoveAt(lookup);\n    }\n}</code></pre>\n<p>under the return false at the top of the function. Then to wrap it all together add the console command to the top of the basecombatweapon_shared.cpp file within <code>#if !defined( CLIENT_DLL )</code></p>\n<pre><code class=\"language-cpp\">void CC_ReloadScript(void)\n{\n    CBasePlayer* pPlayer = UTIL_GetCommandClient();\n    if (pPlayer == NULL)\n        return;\n\n    CBaseCombatWeapon *pWeapon = pPlayer-&gt;GetActiveWeapon();\n    if (pWeapon == NULL)\n        return;\n\n    pWeapon-&gt;ReloadScheme();\n}\n\nstatic ConCommand weapon_reloadscript(&quot;weapon_reloadscript&quot;, CC_ReloadScript);</code></pre>\n"},{"title":"Player bleeding in Source SDK","slug":"bleeding-in-source","date":"2019-11-5","mins":12,"summary":"A random feature I added to a HL2MP mod was for the player to bleed for a bit after being shot, it uses HL2 particles to bleed from bullet holes for a specified amount of time.","contents":"<p>A random feature I added to a HL2MP mod was for the player to bleed for a bit after being shot, it uses HL2 particles to bleed from bullet holes for a specified amount of time. Here&#39;s how I did it:</p>\n<p>First we set up some variables in hl2mp_player.h</p>\n<pre><code class=\"language-cpp\">CNetworkVar( bool, m_bBleeding );\nVector bleedPos;\nVector bleedDir;\nfloat m_flBleedingTime;\nint bleedingAmount;</code></pre>\n<p>and then set the defaults for bleeding in hl2mp_player.cpp (Spawn function)</p>\n<pre><code class=\"language-cpp\">m_bBleeding = false;\nm_flBleedingTime = 0.0f;\nbleedingAmount = 0;</code></pre>\n<p>Still in hl2mp_player but in PostThink we do the actual bleeding based on these variables:</p>\n<pre><code class=\"language-cpp\">if( m_bBleeding &amp;&amp; bleedingAmount &gt; 0 &amp;&amp; m_flBleedingTime &lt; gpGlobals-&gt;curtime )\n{\n    //Bleed a little bit\n    TakeHealth( -1, DMG_GENERIC );\n\n    //Decrement\n    bleedingAmount--;\n    m_flBleedingTime = gpGlobals-&gt;curtime + BLEED_TIME;\n\n    //Finished bleeding\n    if( !bleedingAmount )\n        m_bBleeding = false;\n\n    //Spawn blood\n    UTIL_BloodSpray( bleedPos * GetAbsOrigin(), bleedDir, BloodColor(), bleedingAmount, FX_BLOODSPRAY_ALL );\n    UTIL_BloodDrips( bleedPos, bleedDir, BloodColor(), bleedingAmount );\n}</code></pre>\n<p>Now to actually start bleeding when damage is taken, so in OnTakeDamage we do this:</p>\n<pre><code class=\"language-cpp\">if( inputInfo.GetMaxDamage() != -1.0f )\n{\n    //Bleed!\n    m_bBleeding = true;\n    m_flBleedingTime = gpGlobals-&gt;curtime;\n    bleedingAmount = (int)ceil((float)inputInfo.GetDamage() / 5.0f);\n\n    Vector vecDir = vec3_origin;\n    if( inputInfo.GetInflictor() )\n    {\n        vecDir = inputInfo.GetInflictor()-&gt;WorldSpaceCenter() - Vector ( 0, 0, 10 ) - WorldSpaceCenter();\n        VectorNormalize( vecDir );\n    }\n\n    //Store last took damage\n    bleedPos = inputInfo.GetDamagePosition() / GetAbsOrigin();\n    bleedDir = vecDir;\n}</code></pre>\n<p>Here if the player is damaged we store the direction of the shot and calculate the position based on the offset on the players position. Now we need to network it so the player can see the blood on their end so we pop this in the send table as always:</p>\n<pre><code class=\"language-cpp\">SendPropBool( SENDINFO( m_bBleeding ) )</code></pre>\n<p>and add this to the recieve table in c_hl2mp_player.cpp:</p>\n<pre><code class=\"language-cpp\">RecvPropBool( RECVINFO( m_bBleeding ) )</code></pre>\n<p>and add two new variables to c_hl2mp_player.h:</p>\n<pre><code class=\"language-cpp\">//Bleeding\nbool m_bBleeding;\nfloat m_flTrailTime;</code></pre>\n<p>and set the defaults in Spawn (back in the cpp file) to this:</p>\n<pre><code class=\"language-cpp\">//Bleeding\nm_bBleeding = false;\nm_flTrailTime = 0.0f;</code></pre>\n<p>and now in ClientThink we do the bleeding for the local player!</p>\n<pre><code class=\"language-cpp\">//Bleed!\nif( m_bBleeding &amp;&amp; m_flTrailTime &lt; gpGlobals-&gt;curtime &amp;&amp; GetGroundEntity() )\n{\n    //Do a traceline from the player downwards\n    trace_t tr;\n    UTIL_TraceLine( GetAbsOrigin(), GetAbsOrigin()*Vector(0,0,-10), MASK_SOLID, this, COLLISION_GROUP_NONE, &amp;tr );\n\n    //Draw blood decal and increase time\n    UTIL_BloodDecalTrace( &amp;tr, BLOOD_COLOR_RED );\n    m_flTrailTime = gpGlobals-&gt;curtime+0.5f;\n}</code></pre>\n"},{"title":"Showing Legs in Source SDK","slug":"legs-in-source","date":"2019-08-05T00:00:00.000Z","mins":4,"summary":"An interesting addition to Aftermath was to show the legs of the player, each player could look down at their own player model which allowed each player to have a kind of representation in the game as they can see themselves and know which character they are","contents":"<p>An interesting addition to Aftermath was to show the legs of the player, each player could look down at their own player model which allowed each player to have a kind of representation in the game as they can see themselves and know which character they are.</p>\n<p>This post will be for singleplayer as this is the latest example I have but multiplayer should be similar since it&#39;s only client side code. All the code is in c_baseplayer.cpp &amp; h, first you make sure the model is set for the player:</p>\n<pre><code class=\"language-cpp\">void C_BasePlayer::Spawn( void )\n{\n    SetModel( &quot;models/myplayermodel/playermodel.mdl&quot; );\n}</code></pre>\n<p>This is because the legs come from the player model and the default has no animations and will not look great, next we&#39;ll move the model back so the camera doesn&#39;t clip with the camera.</p>\n<pre><code class=\"language-cpp\">const Vector&amp; C_BasePlayer::GetRenderOrigin( void )\n{\n    //Dont apply in thirdperson\n    if( IsLocalPlayer() &amp;&amp; !input-&gt;CAM_IsThirdPerson() )\n    {\n        static Vector forward;\n        AngleVectors( GetRenderAngles(), &amp;forward );\n\n        // Shift the render origin by a fixed amount\n        forward *= -25;\n        forward += GetAbsOrigin();\n\n        return forward;\n    }else{\n        return BaseClass::GetRenderOrigin();\n    }\n}</code></pre>\n<p>Here we determine the forward position (if we&#39;re not in thirdperson) and use it to change the render origin of the model back a bit, you can change 25 to whatever you want or even use a convar and test it in game.</p>\n<pre><code class=\"language-cpp\">ConVar cl_legs( &quot;cl_legs&quot;, &quot;1&quot;, 0, &quot;Enable or disable player leg rendering&quot;, true, 0, true, 1 );\n\nint C_BasePlayer::DrawModel( int flags )\n{\n    //Ignore if the convar is enabled\n    if( !cl_legs.GetBool() )\n        return 0;\n\n    CMatRenderContextPtr context(materials);\n\n    //Don&#39;t render above a certain height of the body\n    if ( IsLocalPlayer() &amp;&amp; !input-&gt;CAM_IsThirdPerson() )\n    {\n        if ( (GetFlags() &amp; FL_DUCKING) || m_Local.m_bDucking )\n        {\n            context-&gt;SetHeightClipMode(MATERIAL_HEIGHTCLIPMODE_RENDER_BELOW_HEIGHT);\n            context-&gt;SetHeightClipZ(GetAbsOrigin().z+27);\n        }else{\n            context-&gt;SetHeightClipMode(MATERIAL_HEIGHTCLIPMODE_RENDER_BELOW_HEIGHT);\n            context-&gt;SetHeightClipZ(GetAbsOrigin().z+50);\n        }\n    }\n\n    //Draw the model\n    int nDrawRes = BaseClass::DrawModel(flags);\n\n    // Remove height clipping\n    context-&gt;SetHeightClipMode(MATERIAL_HEIGHTCLIPMODE_DISABLE);\n\n    return nDrawRes;\n}</code></pre>\n<p>Here we clip the player model to remove the upperbody and even lower if the player is ducking, there&#39;s also a convar for disabling the legs.</p>\n<p>That&#39;s pretty much it, if you have access to the player models another option is to create a bodygroup and disable several parts of the body as you see fit but this is the easiest option.</p>\n"},{"title":"HTML UI in Source SDK","slug":"html-ui-in-source","date":"2018-12-23T00:00:00.000Z","mins":7,"summary":"I always think I've reached the limits of the Source engine but I think I'm just not giving the engine enough credit, for Resurgence we keep messing around with the UI and one day I had an idea for using the HTML control for it which will allow it to be prototyped faster and allow non-programmers to provide a proper representation instead of an image.","contents":"<p>I always think I&#39;ve reached the limits of the Source engine but I think I&#39;m just not giving the engine enough credit, for Resurgence we keep messing around with the UI and one day I had an idea for using the HTML control for it which will allow it to be prototyped faster and allow non-programmers to provide a proper representation instead of an image.</p>\n<p>I had heard of awesomium but that&#39;s a bit messy and seems to be dead so I started with the HTML VGUI control which creates a CEF off-screen renderer for rendering and renders the result onto a VGUI panel, this was great as a starting point until I noticed a major issue when overriding the main menu VGUI element.</p>\n<h3 id=\"transparency\">Transparency</h3>\n<p>Resurgence has a cool main menu background map and for some reason Valve decided they didn&#39;t need transparency when rendering the HTML control, I poked around a bit and came to the conclusion that pretty much everything was in the chromehtml DLL and although the source is available I wasn&#39;t able to get it built with a old version of CEF.</p>\n<p>I didn&#39;t give up and instead had an idea to use a chroma key and set the background to green, this kinda worked but created issues for text and any transparency that we decided to use for the menu. I kept looking for a solution and while checking out the <a href=\"%22https://github.com/ValveSoftware/source-sdk-2013%22\">Source SDK Github</a> I noticed that the HTML control was slightly different to my version which was weird because Valve have pretty much abandoned it.. I compared the two and basically the off-screen renderer is now handled by the Steam client using the API so I copied over the required files for the HTML control and new Steam API code (which also requires new steam_api and steamvr DLLs) and the off-screen renderer was using a transparent background!</p>\n<h3 id=\"navigation\">Navigation</h3>\n<p>Now that the rendering was working and a HTML file was being loaded I began coding the menu flow and trying to figure out how the user will navigate around the menu. I didn&#39;t want a natural website with static HTML files because I wasn&#39;t sure how opening a bunch of HTML files would look or how fluid it would be so I poked around Javascript libraries and decided to use Vue and it&#39;s Router for navigation.</p>\n<p>The Vue router uses hashes to pretend to be a URL, hashes are normally used for anchors to scroll a user to a specific point but with Javascript you can dynamically set, read and react to hash changes so you can navigate to #/play and Vue will swap an entire section from the default component to another component setup when initialising Vue router with a transition.</p>\n<h3 id=\"data\">Data</h3>\n<p>Now that I had some kind of structure for the new menu I needed to get game data over to Vue and bind it for buttons, text and images. Communication from C++ to the off-screen renderer is very limited compared to if you setup CEF yourself but there&#39;s one function called &quot;ExecuteJavascript&quot; which does exactly what it says and allows you to send JS code.</p>\n<p>The best way would be to use a JSON library to create a structure and send it over once the HTML file has loaded to init Vue, the only issue is Source is pretty old and doesn&#39;t have a JSON library so after trying 3-4 different libs I ended up using <a href=\"%22http://rapidjson.org/%22\">RapidJSON</a> since most newer libs use features that the 2010 built tools don&#39;t support.</p>\n<p>The structure contained the different paths and content within the paths, each button either had a URL to another route or had a custom protocol (res://) that did something specific like loading a map or opening a Steam overlay URL which the mod would handle:</p>\n<pre><code class=\"language-cpp\">const char* url = data-&gt;GetString(&quot;url&quot;);\n\nCUtlVector&lt;char*, CUtlMemory&lt;char*, int&gt;&gt; strs;\nV_SplitString(url, &quot;/&quot;, strs);\nstrs.Remove(0);//remove &quot;res:&quot;\n\nif (strs.Count() &gt;= 0)\n{\n    if (strcmp(strs[0], &quot;menu&quot;) == 0)\n    {\n        char str[100];\n        Q_strncpy(str, &quot;gamemenucommand &quot;, sizeof(str));\n        Q_strncat(str, strs[1], sizeof(str), COPY_ALL_CHARACTERS);\n\n        engine-&gt;ClientCmd(str);\n    }\n    else if (strcmp(strs[0], &quot;command&quot;) == 0)\n    {\n        engine-&gt;ClientCmd(strs[1]);\n    }\n    else if (strcmp(strs[0], &quot;play&quot;) == 0)\n    {\n        g_pCVar-&gt;RevertFlaggedConVars(FCVAR_REPLICATED);\n        g_pCVar-&gt;RevertFlaggedConVars(FCVAR_CHEAT);\n\n        char szMapCommand[1024];\n        Q_snprintf(szMapCommand, sizeof(szMapCommand), &quot;disconnect\\nwait\\nwait\\nsv_lan 0\\nsetmaster enable\\nmaxplayers 1\\nhostname \\&quot;Game Name\\&quot;\\nprogress_enable\\nmap %s\\n&quot;, strs[1]);\n\n        // exec\n        engine-&gt;ClientCmd_Unrestricted(szMapCommand);\n    }\n    else if (strcmp(strs[0], &quot;achievements&quot;) == 0)\n        steamapicontext-&gt;SteamFriends()-&gt;ActivateGameOverlay(&quot;Achievements&quot;);\n}</code></pre>\n<h3 id=\"in-game-state\">In-game state</h3>\n<p>The menu is also used in game and since the UI is now custom the menu it looks exactly the same and needs to be reset when entering a level so I had to check for the engine-&gt;IsInGame() flag to see if it has changed and reset the HTML control and tell Vue to render some components differently, I ended up using the new map game event and navigating the page to root using the router like so:</p>\n<pre><code class=\"language-cpp\">void FireGameEvent(IGameEvent *event)\n{\n    if (strcmp(event-&gt;GetName(), &quot;game_newmap&quot;) != 0)\n        return;\n\n        ...\n\n    html-&gt;RunJavascript(&quot;navigateTo(&#39;/&#39;)&quot;);\n\n        ...\n}</code></pre>\n<p>As well as navigating back to home, the internal JS game data object is updated with an inGame flag so features such as changing the main menu can be achieved.</p>\n<h3 id=\"final-points\">Final points</h3>\n<p>I&#39;ve been slowly expanding the menu out to have difficulty selection, collectibles, loadout and want to move achievements to it. I also recently swapped to using webpack to compile all the vue components into 1-2 js files which is easier to deal with. Here&#39;s a video showing a bit of it:</p>\n<iframe style=\"display: block; margin-left: auto; margin-right: auto;max-width:560px\" src=\"https://www.youtube.com/embed/eyWjmHOO4ko\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"315\" frameborder=\"0\"></iframe>"},{"title":"Enabling brush ladders","slug":"enabling-brush-ladders","date":"2018-7-10","mins":7,"summary":"A request while working on Resurgence was to add brush ladders which are a simpler implementation that don't use dismount points but instead fling you off the ladder at the top or bottom.","contents":"<p>A request while working on Resurgence was to add brush ladders which are a simpler implementation that don&#39;t use dismount points but instead fling you off the ladder at the top or bottom, they are way easier to create in Hammer and easier to use as a player.</p>\n<p>I found out how to do it when searching about the brush ladder and found this <a href=\"%22https://developer.valvesoftware.com/wiki/Co-Operative_Base_(Mod)%22\">page</a> that listed it had managed to enable brush ladders, I checked out the source code for the enabling the brush ladder and it basically just disables the HL2 gamemovement that uses the gamemovement.cpp file as it&#39;s base and has some extra ladder code for handling dismounts. You can check out the file <a href=\"%22https://github.com/whoozzem/SecobMod/blob/master/mp/src/game/shared/hl2/hl_gamemovement.cpp%22\">here</a></p>\n<p>After that any brushes with func_ladder or textures with the climbable flag can be used as ladders, I would recommend changing the climb speed in shareddefs.h (103) and altering the velocity that the player gets pushed away from the ladder at which by default is <a href=\"%22https://github.com/ValveSoftware/source-sdk-2013/blob/master/sp/src/game/shared/gamemovement.cpp#L2939%22\">270</a>.</p>\n<p>It was way easier than I expected as whenever I went to tackle the issue I would look in func_ladder or gamemovement.cpp and didn&#39;t think about checking out the HL2 specific movement rules..</p>\n<p>Code is available on my Github as always, just replace your file with the file in <a href=\"%22https://gist.github.com/tingtom/5a3a92e7146eea8b74873a78edcb8dca%22\">this gist</a></p>\n"}],"limitedProjects":[{"title":"Aftermath","slug":"aftermath","summary":"Aftermath also known as Aftermath:Source and initally Zombie Survival is a HL2 mod created using C++ on the Source engine.","image":"aftermath.png","homepage":true,"contents":"<p>Aftermath also known as Aftermath:Source and initally Zombie Survival is a HL2 mod created using C++ on the Source engine. It began when I decided to create a game similar to Call of Duty&#39;s Zombies mode as I enjoyed playing it and wanted to create something similar, this began with trying to replicate various gameplay features but ended with some custom features to try and seperate itself from the franchise.</p>\n"},{"title":"Dark Metropolis","slug":"dark-metropolis","summary":"Dark Metropolis is a work in progress game based on the idea of working your way up the ladder until you reach the top, the city is randomly generated using a weighted voronoi algorithm.","image":"website.png","homepage":true,"contents":"<p>Dark Metropolis is a work in progress game based on the idea of working your way up the ladder until you reach the top, the city is randomly generated using a weighted voronoi algorithm.</p>\n<iframe style=\"display: block; margin-left: auto; margin-right: auto;max-width:560px\" src=\"https://www.youtube.com/embed/2KGVV4tJWw0\" allowfullscreen=\"allowfullscreen\" width=\"100%\" height=\"315\" frameborder=\"0\"></iframe>\n\n<p>Roads are then extracted from each site and 3d geometry is generated from that, minor and major roads are chosen which then determines the width.</p>\n"},{"title":"Resurgence","slug":"resurgence","summary":"Resurgence deploys you in shoes of a young resistance member, who have escaped from Nova Prospekt thanks to one free man, and is willing to find his old friends in order to reunite and fight together for the future of the human race.","image":"res.png","homepage":true,"contents":"<p>Resurgence deploys you in shoes of a young resistance member, who have escaped from Nova Prospekt thanks to one free man, and is willing to find his old friends in order to reunite and fight together for the future of the human race. Arrive at City 37 to help regain the throne from the falling empire of Combine and bring back the world we all knew at one point.</p>\n"},{"title":"Parkrun Crawler","slug":"parkrun-crawler","summary":"A web application build for crawling Parkrun result tables and importing them into a database, a React frontend is used for displaying and visualising the information.","image":"parkrun.png","homepage":true,"contents":"<p>Parkrun is a collection of 5-kilometre running events that take place every Saturday morning at over 1,400 locations in twenty-three countries across five continents. I&#39;ve been trying to participate in them since the beginning of the year and have a PB of 26:09!</p>\n<p>I thought it would be cool to visualise my progress over the year by parsing their publically accessible results tables and store them in a entity framework driven database and then provide endpoints using controllers and use React and Redux for accessing the information and displaying it.</p>\n<p>It&#39;s been interesting using migrations and the entity framework to generate tables from models as I usually do it the other way around.</p>\n<p>This project will be publically accessible once some more work on the dashboard has been made.</p>\n"}]},"path":"/"}
